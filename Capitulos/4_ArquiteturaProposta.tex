
\chapter{Arquitetura Proposta\label{sec:Arquitetura}}

Este cap√≠tulo apresenta a arquitetura empregada na constru√ß√£o do OpenDevice.
A arquitetura proposta ser√° apresentada em uma vis√£o top-down (de
cima para baixo), onde partiremos de uma abordagem em alto n√≠vel at√©
um n√≠vel mais baixo, apresentando detalhes de implementa√ß√£o. Na primeira
se√ß√£o (\ref{sec:VisaoGeral}), ser√° apresentado a vis√£o geral da arquitetura,
permitindo o entendimento de suas camadas, modelos de comunica√ß√£o,
requisitos e extensibilidade. Na se√ß√£o \ref{subsec:Arquitetura-Detalhada},
ser√° apresentada uma vis√£o mais detalhada dos componentes da arquitetura,
detalhando os m√≥dulos que comp√µe a arquitetura e responsabilidades.
As se√ß√µes \ref{sec:GerenciamentoDispositivos}, \ref{sec:ModeloEventos}
\ref{sec:APIComandos} e \ref{sec:Armazenamento} apresentam os detalhes
de como √© realizada a abstra√ß√£o dos dispositivos e nas se√ß√µes \ref{subsec:ConexoesServidores}
e \ref{subsec:ConexoesCliente}, s√£o apresentados os recursos que
permitem que as aplica√ß√µes clientes se comuniquem com os dispositivos
f√≠sicos, utilizando por exemplo o protocolo MQTT. A se√ß√£o \ref{sec:MecanismoExtensao},
apresenta os mecanismos de extensibilidade que a plataforma oferece,
em complemento ao framework de conex√µes que √© apresentado na se√ß√£o
\ref{subsec:Framework-de-Conexoes}. Na se√ß√£o \ref{subsec:Arquitetura-do-Firmware}
s√£o apresentado os detalhes da arquitetura utilizada na constru√ß√£o
do firmware, um componente importante que permite a cria√ß√£o de dispositivos
(sensores e atuadores) para internet das coisas, utilizando componentes
de baixo custo, de maneira simplificada e extens√≠vel, e com suporte
a v√°rias tecnologias de comunica√ß√£o. Um protocolo simples e f√°cil
de ser implementado √© proposto na se√ß√£o \ref{subsec:Protocolo} ,
para permitir a integra√ß√£o entre software e hardware com baixo poder
de processamento. 


\section{Vis√£o Geral\label{sec:VisaoGeral}}

O OpenDevice √© uma plataforma aberta (\emph{open source}) que tem
como objetivo fornecer uma solu√ß√£o completa para a cria√ß√£o de projetos
baseados na Internet das Coisas. Suas ferramentas abrangem todas as
plataformas envolvidas no ecossistema de IoT: (1) Hardware, (2) Desktop,
(3) Cloud, (4) Mobile, (5) Web, promovendo uma infraestrutura de comunica√ß√£o
entre todas essas camadas, bem como servi√ßos de: (1) Armazenamento,
(2) Controle, (3) Configura√ß√£o, (4) Visualiza√ß√£o. A base da arquitetura
foi constru√≠da usando a linguagem de programa√ß√£o Java, e por ser multi-plataforma,
v√°rios componentes podem ser reutilizados em v√°rias plataformas. Devido
√† limita√ß√£o de recursos de processamento e mem√≥ria de alguns dispositivos
embarcados alvos desse projeto, como no caso dos microcontroladores
AVR/Arduino, um protocolo de n√≠vel de aplica√ß√£o foi elaborado, implementado
e disponibilizado atrav√©s de bibliotecas em C/C++. Hardwares mais
robustos, como no caso do Raspberry, Beaglebone ou outro dispositivo
que tenha uma implementa√ß√£o da JVM dispon√≠vel, podem executar as implementa√ß√µes
em Java diretamente. O OpenDevice oferece mecanismos para implementar
aplica√ß√µes simples ou tratadores de eventos diretamente em JavaScript,
que executam no lado do servidor, algo similar ao Node.js.

Nesta se√ß√£o iremos apresentar uma vis√£o macro da arquitetura e na
se√ß√£o seguinte (\ref{subsec:Arquitetura-Detalhada}) uma vis√£o mais
detalhada. Analisando a figura \ref{fig:Visao-Geral}, podemos observar
a integra√ß√£o dos componentes gerais do projeto, como veremos mais
adiante na se√ß√£o \ref{subsec:ModelosComunicacao}, v√°rios modelos
de comunica√ß√£o (layouts) podem ser utilizados, de acordo com os requisitos
de cada aplica√ß√£o. Projetos para a Internet das Coisas t√™m por caracter√≠stica
principal lidar com uma grande quantidade de atuadores e sensores
heterog√™neos, a camada do Firmware √© respons√°vel por oferecer um n√≠vel
mais alto de abstra√ß√£o dos dispositivos (atuadores e sensores), j√°
que esses podem utilizar diversos protocolos e tratamentos de dados
variados. A integra√ß√£o do firmware com o middleware ou aplica√ß√µes,
ou seja, a integra√ß√£o entre software e hardware, √© um desafio, pois
os protocolos ainda est√£o em fase de desenvolvimento e valida√ß√£o.
Devido a este problema a arquitetura tanto do middleware como do firmware
foi projetada para atender novos requisitos e ter uma f√°cil extensibilidade.
Apesar de n√£o se ter uma padr√£o definido, os principais padr√µes e
tecnologias de comunica√ß√£o foram avaliados e implementados dentro
da arquitetura.

\begin{figure}
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/visao-geral}
\par\end{centering}
\caption{Vis√£o Geral \label{fig:Visao-Geral}}
\end{figure}


\subsection{Componentes da Vis√£o Geral\label{subsec:VisaoGeralComponentes}}
\begin{itemize}
\item \textbf{Middleware (Servidor)} - O middleware tem um papel fundamental
em projetos de IoT, como mencionamos na se√ß√£o \ref{subsec:Fund_Middleware}.
No OpenDevice ele tem o papel de oferecer servi√ßos para as aplica√ß√µes
clientes, fazer o gerenciamento dos dispositivos, gerenciar m√∫ltiplas
conex√µes, fazer armazenamento e disp√µe de m√≥dulos para visualiza√ß√£o
dos dados atrav√©s de dashboards din√¢micos e gr√°ficos em tempo-real
ou hist√≥ricos. Ele foi desenvolvido usando uma estrutura modular e
extens√≠vel, permitindo a inclus√£o de novos componentes e plug-ins
de maneira simplificada. Os desenvolvedores podem optar por utiliz√°-lo
como um servidor √† parte, de modo embarcado ou estendendo-o. Esse
√∫ltimo √© o modo aconselhado caso esteja desenvolvendo aplica√ß√µes na
linguagem Java, pois sua arquitetura foi pensada como um framework,
de modo que os desenvolvedores de projetos de Internet das Coisas
incluam apenas as regras de neg√≥cio, sem se preocupar com os detalhes
de baixo n√≠vel. Projetos escritos em outras linguagens de programa√ß√£o
podem utilizar as APIs REST, MQTT, Socket e WebSocket para se comunicar
com os dispositivos atrav√©s do middleware, que pode ser implantado
em um servidor local (PC / Raspberry Pi) ou na nuvem.O OpenDevice
suporta a cria√ß√£o de aplica√ß√µes em JavaScript, que executam diretamente
na JVM (Java Virtual Machine), o que permite acesso aos m√≥dulos Java
e a cria√ß√£o de interfaces gr√°ficas usando JavaFx.
\item \textbf{Firmware} - O firmware tem o papel de implementar o protocolo
do OpenDevice e fazer o gerenciamento dos dispositivos f√≠sicos (atuadores
e sensores) ligados a ele, criando uma abstra√ß√£o de alto n√≠vel, e
facilitando a integra√ß√£o com a camada de software. Nele, os dispositivos
(sensores e atuadores) s√£o configurados e mapeados para um pino espec√≠fico,
de modo que apenas as informa√ß√µes do dispositivo (ID, Nome, Tipo)
s√£o expostas para as APIs externas, permitindo assim uma maior abstra√ß√£o
dos detalhes do hardware, ou at√© mesmo a substitui√ß√£o do hardware
por outro sem altera√ß√µes na aplica√ß√£o. Podemos pensar no firmware
tamb√©m como um \emph{gateway,} respons√°vel por manter a comunica√ß√£o
com o middleware ou aplica√ß√£o e controlar os dispositivos f√≠sicos.
√â um componente de software projetado para rodar em dispositivos embarcados
com baixo poder de processamento e mem√≥ria, algo em torno de 2KB de
RAM. O foco inicial do desenvolvimento foram os microcontroladores
encontrados em plataformas de prototipa√ß√£o como o Arduino e similares.
Com a expans√£o e popularidade da plataforma do Arduino in√∫meros hardwares
est√£o dando suporte as suas APIs\cite{arduino-comp1,arduino-comp2},
ampliando a compatibilidade do firmware desenvolvido. Na se√ß√£o \ref{par:Hardwares-Testados},
ser√£o apresentados os hardwares testados. A arquitetura do firmware
√© extens√≠vel, permitindo incluir novos dispositivos, novos comandos,
e suporte a novos tipos de conex√µes. Os detalhes do protocolo do OpenDevice
ser√£o apresentados na se√ß√£o \ref{subsec:Protocolo}. O Firmware √©
um componente dispens√°vel quando o projeto utilizar hardwares com
um maior poder de processamento e que tenham suporte a GPIO, como
no caso Raspberry ou BeagleBone. 
\item \textbf{Devices} - Representam os dispositivos f√≠sicos que podem ser
atuadores (representado pela classe \textbf{Device}) ou sensores (representados
pela classe \textbf{Sensor}). Est√£o organizados nos seguintes tipos:
(1) ANALOG, (2) DIGITAL, (3) CHARACTER, que est√£o ligados ao modo
de opera√ß√£o e tipo de dado suportado. Dentro do protocolo os dispositivos
s√£o identificados atrav√©s de um c√≥digo, denominado DeviceID. Os dispositivos
do tipo ANALOG, podem receber uma faixa de valores num√©ricos, j√° os
dispositivos do tipo DIGITAL trabalham com dois estados: 0 (desligado)
e 1 (ligado), os dispositivos do tipo CHARACTER, est√£o aptos a receber
uma String. O OpenDevice trabalha com um modelo orientado a objetos,
permitindo que uma chamada dos m√©todos do \emph{Device} na aplica√ß√£o
cliente, como por exemplo \emph{Device1.on()}, acenda uma l√¢mpada
real ou o realize fechamento de uma garra rob√≥tica. Eles podem ser
independentes ou estarem conectados a um microcontrolador, executando
o firmware, que faz o papel de Gateway. Os desenvolvedores podem estender
essa abstra√ß√£o e adicionar novos comportamentos para os dispositivos
e sensores.
\item \textbf{Clientes} - Representam as aplica√ß√µes clientes, que podem
ser aplica√ß√µes Desktop, web ou \emph{mobile} e podem ser desenvolvidas
em qualquer linguagem. As aplica√ß√µes clientes, podem se comunicar
com o middleware, atrav√©s das interfaces ofertadas (REST, MQTT, Socket,
WebSocket e etc.) ou diretamente com os dispositivos f√≠sicos. Foram
desenvolvidos m√≥dulos de bibliotecas clientes que permitem a integra√ß√£o
com o middleware em linguagens Java e JavaScript e experimentos de
integra√ß√£o usando a linguagem python. Mais detalhes sobre estas implementa√ß√µes
ser√£o vistas na se√ß√£o \ref{subsec:ConexoesCliente}. 
\end{itemize}

\subsection{Modelos de comunica√ß√£o\label{subsec:ModelosComunicacao}}

A arquitetura planejada permite desenvolver projetos em v√°rios Layouts
e modelos de comunica√ß√£o, permitindo atender desde aplica√ß√µes locais,
que se comunicam diretamente com os dispositivos, at√© aplica√ß√µes distribu√≠das,
com comunica√ß√£o atrav√©s da internet.
\begin{itemize}
\item \textbf{Comunica√ß√£o direta} - √â um modelo que permite a comunica√ß√£o
direta entre a aplica√ß√£o final e os dispositivo f√≠sicos. Tem a caracter√≠stica
de ser mais simples, pois neste modelo, n√£o se faz necess√°ria a presen√ßa
do middleware (servidor). A aplica√ß√£o neste cen√°rio pode ser representada
por: (1) um dispositivo mobile, (2) uma aplica√ß√£o desktop ou (3) uma
aplica√ß√£o web. Representando o dispositivo f√≠sico, podemos ter um
hardware que disponibilize um mecanismo de comunica√ß√£o embarcado,
por exemplo o ESP2866, que possui Wi-Fi, ou por exemplo um Arduino
com um m√≥dulo Bluetooth acoplado. Estes dois componentes podem se
comunicar usando diversas tecnologias, como: USB, Bluetooth, Ethernet,
Wi-Fi. Mais detalhes sobre os meios de comunica√ß√£o e como eles s√£o
implementados, ser√£o vistos nas se√ß√µes \ref{subsec:Arquitetura-do-Firmware}
e \ref{subsec:FirmwareGerenciamentoConn}.
\item \textbf{Comunica√ß√£o local (Middleware)} - No modelo de comunica√ß√£o
local, entre em cena um novo componente do OpenDevice, o middleware.
O middleware quando implantado dentro de um projeto pode ser visualizado
como o servidor, e pode ser configurado tanto em um computador convencional,
como em um mini-pc (ex.: Raspberry Pi). A vantagem da inclus√£o deste
elemento √© que ele permite que diversas aplica√ß√µes se comuniquem com
o mesmo dispositivo. Por exemplo, caso uma aplica√ß√£o mobile esteja
conectada via Bluetooth com um dispositivo, outra aplica√ß√£o ser√° impedida
de se comunicar com esse dispositivo, usando middleware, essa limita√ß√£o
√© contornada, j√° que o middleware recebe os comandos das aplica√ß√µes
cliente e faz o redirecionamento para o dispositivo desejado. Outra
vantagem √© que o middleware pode gerenciar v√°rias conex√µes com os
dispositivos, utilizando v√°rios meios de comunica√ß√£o, liberando essa
carga de gerenciamento das aplica√ß√µes. Neste modelo de comunica√ß√£o,
os dispositivos podem operar no modo servidor, aguardando a conex√£o
por parte do middleware, ou no modo cliente.
\item \textbf{Comunica√ß√£o pela Internet} - Neste modelo as aplica√ß√µes podem
se comunicar com os dispositivos atrav√©s da internet. Para isso, os
dispositivos devem possuir um hardware que suporte uma conex√£o usando
o protocolo TCP/IP, necessitando apenas de um roteador convencional
para interliga√ß√£o com a internet ou um modem GSM/GPRS. Neste cen√°rio
os dispositivos atuam no modo cliente e o middleware est√° implantado
em um servidor na nuvem.
\item \textbf{Comunica√ß√£o pela Internet, usando um middleware local} - Neste
modelo um middleware local √© aplicado novamente, permitindo que as
aplica√ß√µes continuem funcionando caso a internet n√£o esteja dispon√≠vel
ou quando √© necess√°rio integrar dispositivos que n√£o possuem suporte
o protocolo TCP/IP. Neste modelo, a mesma vers√£o do middleware est√°
rodando em um servidor local e em um servidor na nuvem, diferenciando
apenas os m√≥dulos e infraestrutura utilizada, j√° que em um servidor
local a mem√≥ria e recursos s√£o limitados e num servidor de nuvem √©
necess√°rio uma performance e alta escalabilidade.
\end{itemize}

\subsection{Requisitos\label{subsec:Requisitos}}

A arquitetura foi projetada para ser adapt√°vel √†s capacidades e necessidades
de casos de uso espec√≠ficos. Esses podem ser categorizados como:
\begin{itemize}
\item \textbf{Requisitos de Comunica√ß√£o} - O sistema deve ser apoiado em
eventos e/ou comunica√ß√£o aut√¥noma. Os dispositivos devem ser configurados
e controlados remotamente. O sistema deve suportar comunica√ß√£o em
tempo-real. O sistema dever√° fornecer comunica√ß√£o segura e confi√°vel.
O sistema deve prover recursos para extens√£o dos protocolos de comunica√ß√£o.
\item \textbf{Gerenciamento de dispositivos} - A API deve prover uma interface
para o controle dos dispositivos. Isso inclui a configura√ß√£o do dispositivo
bem como ativa√ß√£o, desativa√ß√£o e atualiza√ß√£o remota.
\item \textbf{Servi√ßos de Descoberta }- O sistema deve oferecer mecanismos
para descoberta e vincula√ß√£o de novos dispositivos.
\item \textbf{Capacidades do dispositivo} - A API deve prover informa√ß√µes
sobre as capacidades dos dispositivos.
\item \textbf{Requisitos de comunica√ß√£o cliente/servidor} - A API deve prover
suporte para operar os dispositivos tanto no modo cliente como no
modo servidor.
\item \textbf{Requisitos de monitoramento de status} - Status como n√≠vel
de bateria, temperatura, estado de opera√ß√£o dentro da infraestrutura
devem estar acess√≠veis.
\item \textbf{Servi√ßo de Armazenamento} - A API deve oferecer recursos para
armazenamento das informa√ß√µes sobre os dispositivos, bem como mecanismo
para obter o hist√≥rico dos dados do dispositivo.
\item \textbf{Servi√ßo de Visualiza√ß√£o} - A API deve oferecer servi√ßo para
an√°lise dos dados, recursos para consultas hist√≥ricas, fun√ß√µes para
agrupamento e agrega√ß√£o dos dados, bem como componentes visualiza√ß√£o
atrav√©s de gr√°ficos.
\item \textbf{Orientado a Eventos} - O sistema deve oferecer um sistema
para tratamento de eventos, notificando as partes interessadas quando
alguma mudan√ßa de estado ocorrer nos dispositivos.
\item \textbf{Interoper√°vel entre v√°rias redes (PAN, LAN e WAN)} - Precisa
trabalhar atrav√©s de uma variedade de redes e protocolos, tanto com
redes IP e n√£o-IP, incluindo dispositivos de baixa pot√™ncia (low-power)
em redes como Z-Wave, Zigbee e Bluetooth. 
\item \textbf{Extens√≠vel} - Deve fornecer recursos que permitam a inclus√£o
de novos componente e funcionalidades atrav√©s de extens√µes ou plug-ins.
\item \textbf{Independ√™ncia de Plataforma} - A API de servi√ßos deve ser
multi-plataforma, executando nos principais sistema operacionais encontrados
no mercado.
\end{itemize}

\subsection{Extensibilidade\label{subsec:VisaoGeral-Extensibilidade}}

Toda a arquitetura do OpenDevice foi pensada visando uma f√°cil extensibilidade,
permitindo inclus√£o de novos protocolos, novos m√≥dulos de comunica√ß√£o
e integra√ß√£o com outras ferramentas. Devido √† grande diversidade de
√°reas, requisitos e dom√≠nios variados que projetos de Internet das
Coisas podem ser empregadas, e por ser uma √°rea relativamente nova,
√© uma tarefa complexa desenvolver uma plataforma/Framework que atenda
a todos os requisitos. Esse trabalho oferece contribui√ß√µes com uma
base s√≥lida para cria√ß√£o de outros projetos especializados para outros
dom√≠nios como automa√ß√£o residencial, sa√∫de, cidades inteligentes e
etc, por√©m sua estrutura generalista pode ser empregada para criar
v√°rios projetos sem necessidade de modifica√ß√µes, no cap√≠tulo \ref{sec:Avaliacao-Experimental}
ser√° realizada uma avalia√ß√£o experimental, usando como base o dom√≠nio
da automa√ß√£o residencial para validar a arquitetura, com base na sua
aplica√ß√£o generalista e nas suas capacidades de extensibilidade.

No contexto de extensibilidade, foram analisadas algumas estrat√©gias
de implementa√ß√£o de suporte a plug-ins e m√≥dulos din√¢micos, uma das
solu√ß√µes mais promissoras nesse campo √© o OSGI (Open Services Gateway
Initiative)\cite{osgi}, por√©m foi descartado por considerarmos que
√© uma ferramenta que adiciona uma complexidade extra no desenvolvimento
das extens√µes e necessita de um gerenciamento complexo que √© feito
pelo cont√™iner de OSGI, consequentemente consumindo mais recursos.
A solu√ß√£o adotada √© baseada em uma ferramenta dispon√≠vel pela pr√≥pria
linguagem Java, o SPI (Service Provider Interfaces), que tem como
objetivo, de oferecer recursos de extens√£o de forma simples e leve,
baseando-se apenas em interfaces que s√£o definidas pelo pr√≥prio OpenDevice
e um arquivo de configura√ß√£o simples. Uma pequena desvantagem encontrada
no mecanismo do SPI √© que ele n√£o permite o carregamento din√¢mico
de plug-ins em tempo de execu√ß√£o, apenas no carregamento da aplica√ß√£o.


\section{Arquitetura detalhada\label{subsec:Arquitetura-Detalhada}}

Nesta se√ß√£o, veremos os detalhes da arquitetura empregada na constru√ß√£o
do projeto OpenDevice, analisando os m√≥dulos individualmente, os blocos
funcionais e suas responsabilidades.

Uma das considera√ß√µes importantes no desenvolvimento desse projeto
√© que o core da arquitetura e os m√≥dulos servidores principais~(MQTT,
Rest e WebSocket) pudessem ser executados em hardwares de baixo poder
de processamento, algo em torno de 512MB de RAM e 500Mhz de CPU. Com
base nessa restri√ß√£o, foram desenvolvidos m√≥dulos de servidores que
executam em modo embarcado(\emph{embedded}), j√° que as solu√ß√µes dispon√≠veis
de servidores Java como: Tomcat , Jetty, JBoss ou GlassFish, iriam
consumir muitos recursos da m√°quina. O mesmo crit√©rio foi aplicado
na sele√ß√£o do banco de dados, que √© um componente opcional. Solu√ß√µes
embarcadas foram adotadas em rela√ß√£o √† solu√ß√µes instaladas separadamente
(ex.: MySQL), facilitando o desenvolvimento e distribui√ß√£o da aplica√ß√£o.

A camada do middleware, das aplica√ß√µes clientes e firmware s√£o baseadas
no modelo de desenvolvimento orientado eventos (\emph{Event-Driven}),
realizada atrav√©s do envio e recebimento de comandos, usando comunica√ß√µes
em tempo-real. O modelo baseado em eventos facilita o desenvolvimento
de aplica√ß√µes de IoT, principalmente quando √© necess√°ria a intera√ß√£o
com sensores, permitindo que os desenvolvedores registrem que tipo
de evento ou os dispositivos que desejam monitorar, e quando o evento
ocorrer, como por exemplo um sensor mudar seu valor, os interessados
no evento ser√£o notificados. Esse modelo tamb√©m permite uma f√°cil
extens√£o da ferramenta, pois tira a responsabilidade das extens√µes
de conhecer fluxo de conex√£o e aspectos internos do funcionamento,
podendo agregar fun√ß√µes mais elaboradas para lidar com os eventos,
como por exemplo, um algoritmo de intelig√™ncia artificial (IA) que
fa√ßa predi√ß√£o.

Na Figura \ref{fig:Arquitetura} pode-se observar a arquitetura e,
cada camada, assim como, cada elemento ser√° explicado a seguir. 

\begin{figure}
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/arquitetura}
\par\end{centering}
\caption{Arquitetura detalhada\label{fig:Arquitetura}}
\end{figure}


\subsection{Camadas da Arquitetura}
\begin{itemize}
\item \textbf{Camada de Aplica√ß√£o (User Application APIs)} - Constituem
os m√≥dulos e bibliotecas disponibilizados para utiliza√ß√£o pelas aplica√ß√µes
clientes, permitindo a integra√ß√£o com o OpenDevice. A maioria dos
m√≥dulos s√£o projetados para que as aplica√ß√µes se comuniquem com os
dispositivos f√≠sicos (hardware) atrav√©s do middleware, por√©m est√£o
dispon√≠veis m√≥dulos que permitem a comunica√ß√£o direta entre a aplica√ß√£o
cliente e o hardware. Foram desenvolvidos m√≥dulos clientes para Web,
Desktop e Android, os detalhes da implementa√ß√£o e tecnologias suportadas
ser√£o abordados na se√ß√£o \ref{subsec:ConexoesCliente}.
\item \textbf{Middleware} - O middleware √© uma camada altamente modular
e customiz√°vel, que oferece uma s√©rie de servi√ßos para as aplica√ß√µes,
como mencionamos na se√ß√£o \ref{subsec:VisaoGeralComponentes} (Componentes
da Vis√£o Geral). Ele √© a pe√ßa central que permite a comunica√ß√£o das
aplica√ß√µes com os hardwares utilizando uma linguagem de alto-n√≠vel.
O middleware foi desenvolvido para uma f√°cil extens√£o, devido a essa
caracter√≠stica, ele se torna um framework para cria√ß√£o de projetos
de Internet das Coisas. Conta com um poderoso framework de conex√µes,
respons√°vel pelas defini√ß√µes do protocolo, comunica√ß√£o com os dispositivos
f√≠sicos e integra√ß√£o com as aplica√ß√µes. Mais detalhes e sub-componentes
ser√£o abordados a seguir.
\item \textbf{Hardware} - Os hardwares podem ser classificados em microcontroladores
e Mini PCs. Para os microcontroladores s√£o disponibilizadas bibliotecas,
que chamamos nesse trabalho de firmware, que permitem uma f√°cil integra√ß√£o
com o middleware (servidor) e facilitam a cria√ß√£o de objetos inteligentes.
Elas d√£o suporte a utiliza√ß√£o de v√°rias tecnologias de comunica√ß√£o,
como: Usb, Bluetooth, Ethernet e Wi-Fi. Essas bibliotecas s√£o baseadas
no framework do Arduino, o que as tornam compat√≠veis com uma s√©ries
de Hardwares e plataformas de prototipa√ß√£o, inclusive que n√£o fazem
parte do projeto do Arduino\cite{arduino-comp1,arduino-comp2,arduino-comp3}.
Quando se trata de Mini PCs, que envolvem hardwares de maior poder
de processamento e mem√≥ria, como por exemplo, Raspberry~Pi e BeagleBone,
√© poss√≠vel executar o middleware diretamente neles, desde que se tenha
dispon√≠vel uma implementa√ß√£o da JVM para esses dispositivos. Nos Mini
PCs, o acesso aos pinos de GPIO ainda √© um problema, pois cada hardware
possui suas especifica√ß√µes. O projeto Device I/O \cite{device-io:wiki},
mantido pela comunidade do OpenJDK, tem a proposta de criar uma implementa√ß√£o
para o acesso aos perif√©ricos desses dispositivos, por√©m ainda est√°
em fase de desenvolvimento. Para hardwares n√£o suportados pelo projeto,
existem tr√™s alternativas: (1) criar adaptadores/Wrapper para bibliotecas
j√° existentes, (2) implementar chamadas JNI ou (3) usar o drivers
baseados em \emph{Sysfs} que alguns Kernels disponibilizam para acessar
a GPIO como fossem simples arquivos\cite{key-sysfs}.
\end{itemize}

\subsection{M√≥dulos}

Nesta se√ß√£o, abordaremos os m√≥dulos que comp√µe a arquitetura. Na Figura
\ref{fig:Modulos} pode-se observar os m√≥dulos, assim como, cada elemento
ser√° explicado a seguir. 

\begin{figure}
\begin{centering}
\includegraphics[width=1\textwidth]{/media/ricardo/Dados/Dropbox/Mestrado/Dissertacao/Imagens/Cap_4/OpenDevice_Modulos}
\par\end{centering}
\caption{M√≥dulos\label{fig:Modulos}}
\end{figure}

\begin{enumerate}
\item M√≥dulos Gerais

\begin{enumerate}
\item \noun{core}: M√≥dulo base da arquitetura, com o sistema de gerenciamento
de dispositivos, sensores, conex√µes, eventos, armazenamento, API de
comandos e implementa√ß√£o do protocolo. Esse m√≥dulo pode ser usado
no desenvolvimento de aplica√ß√µes Desktop, Web ou Mobile;
\item \noun{rest-api}: Defini√ß√µes das interfaces REST para controle dos
dispositivos e sensores;
\item \noun{js-engine: }Implementa√ß√£o do suporte a execu√ß√£o de JavaScript
no lado do servidor;
\item \noun{web-view}: Interface HTML/5 + AngularJS + OpenDeviceJS;
\item \noun{middleware: }Aplica√ß√£o de gest√£o, controle e monitoramento,
que usa a maior parte dos m√≥dulos do OpenDevice, usando o banco de
dados Neo4J + Hibernate OGM (JPA).
\end{enumerate}
\item M√≥dulos do framework de conex√µes

\begin{enumerate}
\item \noun{connection-api}: Especifica√ß√£o das interfaces de conex√£o cliente/servidor;
\item \noun{connection-stream}: Implementa√ß√µes de conex√µes USB, Bluetooth,
TCP (PC/RaspPI);
\item \noun{android-stream}: Implementa√ß√£o de conex√µes USB, Bluetooth para
Android\footnote{\begin{enumerate}
\item Demais conex√µes (Rest, WebSocket, MQTT) podem ser utilizada no Android
atrav√©s dos outros m√≥dulos.
\end{enumerate}
};
\item \noun{raspberry-pi4j}: Comunica√ß√£o com a GPIO do Raspberry usando
PI4J.
\end{enumerate}
\item M√≥dulos Cliente

\begin{enumerate}
\item \noun{opendevice-js}: Biblioteca JavaScript com suporte a WebSocket
e REST;
\item \noun{opendevice-wasync-client}: Biblioteca WebSocket para Android
e PC;
\item \noun{python-client}: Biblioteca em Python com suporte a TCP.
\end{enumerate}
\item M√≥dulos Servidores

\begin{enumerate}
\item \noun{rest-ws-server}: Servidor REST e WebSocket;
\item \noun{opendevice-mqtt}: Servidor MQTT;
\end{enumerate}
\item Bibliotecas para hardware

\begin{enumerate}
\item opendevice-lib-arduino: Bibliotecas em C++ baseadas na API do Arduino,
que implementa o protocolo do OpenDevice e s√£o usadas para cria√ß√£o
do firmware. Prov√™ suporte ao gerenciamento de dispositivos e conex√µes:
USB, Bluetooth, Wi-Fi, Ethernet. Veja a lista de placas testadas na
se√ß√£o~\ref{par:Hardwares-Testados}.
\end{enumerate}
\end{enumerate}

\section{Gerenciamento de Dispositivos\label{sec:GerenciamentoDispositivos}}

Um dos principais requisitos de uma arquitetura de Internet das Coisas
√© realizar a abstra√ß√£o dos dispositivos, permitindo lidar com a sua
grande heterogeneidade. No OpenDevice as abstra√ß√µes base s√£o implementadas
atrav√©s das classes Device e Sensor. Algumas implementa√ß√µes de clientes
sofrem algumas varia√ß√µes nessa abstra√ß√£o, como por exemplo no cliente
JavaScript \noun{opendevice-js,} onde existe apenas a classe \emph{Device}
e a identifica√ß√£o, se √© um sensor ou atuador, √© feita atrav√©s de um
atributo, j√° que nessa linguagem n√£o temos suporte a orienta√ß√£o a
objetos. 

O OpenDevice permite a conex√£o com v√°rios hardwares ao mesmo tempo,
cada hardware (ex.: Arduino) pode gerenciar v√°rios sensores e atuadores,
cada sensor e atuador √© interpretado como um ``\emph{Device}'' e
recebe um ID (DeviceID) √∫nico na plataforma, que pode ser codificado
manualmente ou dinamicamente. Quando o m√≥dulo cliente ou o middleware
estabelece uma conex√£o com o hardware (ex.: Arduino), ele solicita
as defini√ß√µes dos dispositivos que foram configurados. A biblioteca
(firmware) instalada no hardware, cuida de todo o processo de negocia√ß√£o.
A configura√ß√£o de dispositivos no hardware pode ser feita de forma
est√°tica, atrav√©s de uma pre-configura√ß√£o, ou din√¢mica, atrav√©s de
comandos. No hardware, os dispositivos s√£o mapeados de forma a vincular
o pino do microcontrolador com um ID (DeviceID), de modo que as aplica√ß√µes
externas conhe√ßam o apenas ID, criando uma abstra√ß√£o do hardware final,
permitindo mudan√ßas sem afetar a aplica√ß√£o. Os hardwares, atuariam
como um Gateway, podendo ser identificados atrav√©s de um nome ou ID,
e seriam respons√°veis por controlar sensores e atuadores, e integra-los
√†s aplica√ß√µes. 

A listagem \ref{alg:devices1} apresenta um exemplo (em Java) da configura√ß√£o
dos dispositivos e conex√£o. Ao instanciar uma classe Device dentro
de uma classe que estende \emph{LocalDeviceManager, }eles passam a
ser gerenciados pelo OpenDevice, e qualquer altera√ß√£o dos valores
dos dispositivos (ex.: \emph{led.on()} e \emph{led.off()}), resulta
em um envio de um comando para o hardware, que verifica o ID do dispositivo
e faz o mapeamento para o pino correspondente. No lado do hardware/firmware
(listagem \ref{alg:devices2}), a configura√ß√£o dos dispositivos foi
realizada de forma est√°tica, onde foram adicionados dois dispositivos:
(1) um atuador digital (led), conectado no pino 5 do Arduino e (2)
um sensor digital (switch), conectado no pino 3. A associa√ß√£o do ID
para cada dispositivo foi realizada de forma autom√°tica e sequencial,
por√©m √© poss√≠vel especificar um ID manualmente. 

Ao pressionar o sensor f√≠sico (ID=2), o firmware reconhece a altera√ß√£o
no seu estado e envia uma notifica√ß√£o para a aplica√ß√£o (ou middleware),
que chama o evento ``onChange'' do dispositivo especificado e notifica
outros componentes (incluindo extens√µes) que foram registrados para
esse evento. No evento disparado, no exemplo na listagem \ref{alg:devices1},
ele verifica o status atual do bot√£o (linha 11), se estiver ligado/pressionado,
ele chama o m√©todo \emph{``on()''} do led. O OpenDevice detecta
essa altera√ß√£o e envia o comando para o hardware (firmware) e este
faz o acionamento do pino correspondente ao dispositivo. Mais detalhes
sobre os fluxos de execu√ß√£o de comandos s√£o apresentados na se√ß√£o
\ref{subsec:FluxoMensagens}.

O exemplo apresentado demonstra a integra√ß√£o entre uma aplica√ß√£o e
um hardware baseado em um microcontrolador, que tem um recursos extremamente
limitados. Em hardwares com maior poder de processamento, denominados
Mini-PCs (ex.: Raspberry), √© poss√≠vel executar a aplica√ß√£o e fazer
o controle dos dispositivos diretamente, pois ele permite acesso aos
perif√©ricos (pinos GPIO). A listagem \ref{alg:devices3}, apresenta
um exemplo resumido de como realizar o mapeamento dos dispositivos
para os pinos correspondentes do RaspberryPi.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[numbers=left]
// alguns trechos de cÛdigo foram omitidos
public class BlinkButtonDemo extends LocalDeviceManager{

    public BlinkButtonDemo() {

        final Device led = new Device(1, Device.DIGITAL);
        final Device btn = new Sensor(2, Device.DIGITAL);

        connect(out.bluetooth("00:13:03:14:19:07"));

        btn.onChange(device -> {
            if(btn.isON()){
                led.on();
            }else{
                led.off();
            }
        });
    }
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Configura√ß√£o dos dispositivos - Java\label{alg:devices1}}
\end{algorithm}

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
// alguns trechos de cÛdigo foram omitidos
void setup(){
    ODev.name("ModuleName");
    ODev.addDevice(5, Device::DIGITAL); // ID:1 - led 
    ODev.addSensor(3, Device::DIGITAL); // ID:2 - button
    ODev.begin(Serial1, 9600);
}

void loop(){
  ODev.loop();
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Configura√ß√£o dos dispositivos no Arduino - Firmware/C\label{alg:devices2}}
\end{algorithm}

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
// alguns trechos de cÛdigo foram omitidos
Device led = new Device(1, DeviceType.DIGITAL).gpio(1);
// ...
connect(new RaspberryGPIO());
\end{lstlisting}
\inputencoding{utf8}
\caption{Configura√ß√£o dos dispositivos no Raspberry - Java \label{alg:devices3}}
\end{algorithm}


\section{Modelo Orientado a Eventos\label{sec:ModeloEventos}}

O design da arquitetura segue um modelo orientado a eventos, ou \emph{Event-Driven},
que permite desacoplar os componentes da arquitetura e aplica√ß√µes.
Este desacoplamento pode ser de tempo, espa√ßo ou sincroniza√ß√£o\cite{key-eventd}. 

O mecanismo de eventos √© importante na constru√ß√£o do framework, pois
ele √© considerado mais eficiente e escal√°vel do que o modelo baseado
em \emph{Polling}, que √© um mecanismo s√≠ncrono de requisi√ß√£o e resposta,
que pode introduzir uma lat√™ncia na comunica√ß√£o e no tempo de resposta\cite{key-poll2}.
Esse mecanismo tamb√©m permite a isola√ß√£o das aplica√ß√µes, de saber
qual a frequ√™ncia com que os dispositivos geram os dados, passando
apenas a utilizar um mecanismo de ``observar'' os dispositivos,
e reagir aos eventos quando eles acontecem.

Os eventos gerados pelas aplica√ß√µes clientes, s√£o direcionados para
o middleware ou diretamente para os dispositivos, de forma autom√°tica
e transparente. Os principais eventos gerados pela arquitetura s√£o:
mudan√ßa do estado do dispositivo, associa√ß√£o de novos dispositivos,
mudan√ßa no estado das conex√µes, por√©m exitem outros e novos podem
ser criados. √à poss√≠vel monitorar eventos gerados por dispositivos
individuais, registrado ouvintes (listeners) para as inst√¢ncias especificas,
ou para todos os dispositivos, registando ouvintes (listeners) no
gerenciador de dispositivos (\emph{DeviceManager}).

Um exemplo foi apresentado na se√ß√£o \ref{sec:GerenciamentoDispositivos},
listagem \ref{alg:devices1}, onde √© adicionado um ``ouvinte'' no
dispositivo e quando o valor dele mudar, o ``ouvinte'' √© executado.
No exemplo citado, o ``ouvinte'' ao ser executado, faz a chamada
do m√©todo ``led.on()'', gerando um evento (comando) que √© despachado
para os componentes interessados. Um dos interessados √© o \emph{CommandDelivery},
que cuida do envio e monitoramento da entrega do comando, atrav√©s
das conex√µes de sa√≠da. Outro interessado √© o servi√ßo de armazenamento
que, se habilitado, registra o hist√≥rico de altera√ß√µes dos valores
dos dispositivos.

Algumas bibliotecas disponibilizadas para constru√ß√£o de aplica√ß√µes
clientes se baseiam no sistema Publish/Subscribe, que permite um
baixo acoplamento e uma alta escalabilidade. Um dos exemplos √© a
biblioteca JavaScript para desenvolvimento de aplica√ß√µes WEB, \noun{opendevice-js},
que utiliza o procolo de comunica√ß√£o WebSocket e consegue interagir
(envio e recebimento) com os dispositivos praticamente em tempo-real.


\section{API de Comandos\label{sec:APIComandos}}

As informa√ß√µes trocadas entre hardware, middleware e aplica√ß√µes clientes
s√£o baseadas em mensagens, que s√£o chamadas de comandos e s√£o representadas
pela classe base \emph{Command}. Esses comandos s√£o convertidos no
protocolo do OpenDevice (mais detalhes ser√£o vistos na se√ß√£o \ref{subsec:Protocolo}),
atrav√©s dos serializadores. O framework permite a comunica√ß√£o com
os hardwares e controle dos dispositivos, utilizando apenas os comandos,
sem utilizar as abstra√ß√µes obtidas com os dispositivos (classe \emph{Device}
e \emph{Sensor}). A listagem \ref{alg:command} mostra um exemplo
da equival√™ncia da opera√ß√£o usando a classe \emph{Device} e usando
os comandos. A classe DeviceCommand, permite o envio de comandos do
tipo DIGITAL e ANAL√ìGICO. O recebimento de informa√ß√µes geradas pelo
hardware ou de outro componente (ex.:aplica√ß√£o cliente), √© realizada
atrav√©s de comandos. Para realizar o monitoramento e recebimento desses
comandos √© necess√°rio adicionar os ouvintes (listeners) nas conex√µes,
um exemplo simplificado √© apresentado na listagem \ref{alg:command-1}.
Ao enviar um comando para o hardware, ele ir√° responder com uma mensagem
de status, que √© representada pela classe \emph{ResponseCommand},
permitindo identificar se os comandos foram recebidos corretamente
ou n√£o. O envio das mensagens √© gerenciado pelo \emph{CommandDelivery},
que permite direcionar a mensagem para a conex√£o certa e monitorar
a entrega. Caso ela n√£o seja feita, devido a um delay ou falha de
comunica√ß√£o, ele notifica a aplica√ß√£o com um erro de \emph{timeout}
detalhes desse fluxo ser√£o apresentados na se√ß√£o \ref{subsec:FluxoMensagens}.
A figura \ref{fig:DiagCommands} mostra um diagrama de classe simplificado
da API de comandos. Essa API promove mais uma camada de abstra√ß√£o,
permitindo que, caso as implementa√ß√µes atuais dos dispositivos (Device
e Sensor) n√£o sejam suficientes, elas possam ser substitu√≠das.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
// Usando a API de comandos
DeviceConnection conn = Connections.out.usb();
conn.send(DeviceCommand.ON(1)); // '1' is DeviceID

// Usando a abstraÁ„o
Device led = new Device(1, Device.DIGITAL);
led.on();
\end{lstlisting}
\inputencoding{utf8}
\caption{Compara√ß√£o da API de comandos e Devices \label{alg:command}}
\end{algorithm}

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
DeviceConnection conn = Connections.out.usb();
conn.addListener(new ConnectionListener() {
    public void onMessageReceived(Message message, DeviceConnection connection) {
        String type = message.getClass().getSimpleName();
        System.out.println("onMessageReceived("+type+"): "+ message);
    }
});
\end{lstlisting}
\inputencoding{utf8}
\caption{Monitorando recebimento de comandos \label{alg:command-1}}
\end{algorithm}

\begin{figure}
\begin{centering}
\includegraphics[width=0.7\linewidth]{Imagens/Cap_4/commands-api}
\par\end{centering}
\caption{Diagrama de classe simplificado dos Comandos\label{fig:DiagCommands}}
\end{figure}


\section{Mecanismo de extens√£o\label{sec:MecanismoExtensao}}

Como mencionado na se√ß√£o \ref{subsec:VisaoGeral-Extensibilidade},
o mecanismo de extens√£o da arquitetura √© baseado no SPI (Service Provider
Interface), um recurso simples e leve, dispon√≠vel no Java 6 e posteriores.
Embora a arquitetura tenha sido projetada como um framework, para
ser usado como base para cria√ß√£o de projetos mais especializados,
existe uma implementa√ß√£o padr√£o, denominada \emph{middleware}, que
permite customiza√ß√µes atrav√©s de extens√µes/plug-ins. Os mecanismos
de extens√£o padr√£o est√£o voltados para: (1) conex√µes, permitindo adicionar
novas conex√µes ou substituir por implementa√ß√µes mais eficientes, (2)
tratadores de eventos, que permitem plugar estrat√©gias de tratamento
de eventos, e (3) sistema de armazenamento. As extens√µes s√£o implementadas
atrav√©s da interface \emph{OpenDeviceExtension}, que s√£o inicializadas
durante o carregamento da aplica√ß√£o. Para que as extens√µes sejam carregadas
corretamente √© necess√°rio que no m√≥dulo (.jar), seja inclu√≠do o arquivo
de configura√ß√£o na pasta: \emph{resources/META-INF/services,} com
o nome:\emph{ br.com.criativasoft.opendevice.engine.js.ExtensionPoint},
seguindo as especifica√ß√µes do SPI. As conex√µes seguem um mecanismo
similar, por√©m possuem seus pontos de extens√£o individualizados para
cada tipo de conex√£o, como foi visto na figura \ref{fig:DiagConections}.


\subsection{Framework de Conex√µes\label{subsec:Framework-de-Conexoes}}

O framework de conex√µes foi projetado para ser usado de forma independente
do restante da arquitetura. A figura \ref{fig:DiagConections} mostra
a hierarquia base das conex√µes suportadas pela arquitetura. Essas
interfaces s√£o os pontos de extens√£o, permitindo que implementa√ß√µes
possam ser utilizadas de acordo com a plataforma ou mesmo trocadas
por uma implementa√ß√£o mais eficiente. A figura \ref{fig:DiagConections2}
mostra um exemplo de implementa√ß√£o da conex√£o Bluetooth. A implementa√ß√£o
para aplica√ß√µes Desktop √© fornecida pelo m√≥dulo \noun{connection-stream},
j√° a implementa√ß√£o para aplica√ß√µes Android s√£o fornecidas pelo m√≥dulo
\noun{android-stream}, dessa maneira √© poss√≠vel que uma aplica√ß√£o
possa ser portada sem modifica√ß√µes no seu c√≥digo base para outras
plataformas. No OpenDevice a implementa√ß√£o correta √© escolhida pela
f√°brica de conex√µes, usando \emph{Connections.out.bluetooth(``...'').}
Esta f√°brica est√° dispon√≠vel no m√≥dulo core, e possui m√©todo para
cria√ß√£o das principais tecnologias de comunica√ß√£o suportadas, tanto
clientes, como servidores. Os principais componentes desse framework
e suas descri√ß√µes s√£o listadas a seguir.

\begin{figure}
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/connections}
\par\end{centering}
\caption{Diagrama de classe das conex√µes\label{fig:DiagConections}}
\end{figure}

\begin{figure}
\begin{centering}
\includegraphics[width=0.7\linewidth]{Imagens/Cap_4/connections-bluetooth}
\par\end{centering}
\caption{Exemplo de implementa√ß√£o da conex√£o bluetooth\label{fig:DiagConections2}}
\end{figure}

\begin{itemize}
\item DeviceConnection - Interface base para todos as conex√µes do sistema,
define o modo de opera√ß√£o geral das conex√µes e em conjunto com o \emph{MessageSerializer}
define o modelo de protocolo a ser utilizado. Possui uma implementa√ß√£o
base, atrav√©s da classe \emph{AbstractConnection}, que facilita a
cria√ß√£o de implementa√ß√µes finais. 
\item MessageSerializer - Como mencionado anteriormente, √© o componente
respons√°vel pela serializa√ß√£o e desserializa√ß√£o das mensagens enviadas
e recebidas pelas conex√µes. S√£o as implementa√ß√µes que definem o tamanho
e formato das mensagens. A implementa√ß√£o padr√£o, localizada no m√≥dulo
core, √© feita pela classe \emph{CommandStreamSerializer}. 
\item ConnectionListener - Interface que permite monitorar de forma plug√°vel
os eventos ocorridos na conex√£o, como conex√£o, desconex√£o e recebimento
de mensagens, permitindo √†s aplica√ß√µes reagirem √† esses eventos. V√°rios
ouvintes de eventos (Listeners) podem ser adicionados √†conex√£o.
\item Message - Interface que encapsula os dados enviados e recebidos, exemplos
de implementa√ß√µes s√£o \emph{ByteMessage}, \emph{Request}, etc. A implementa√ß√£o
base usada no OpenDevice √© realizada pela classe \emph{Command}, localizada
no m√≥dulo core.
\end{itemize}
No OpenDevice, esse framework √© utilizado em duas camadas: (1) conex√µes
de entrada (Input), que s√£o os servidores e t√™m por objetivo disponibilizar
os servi√ßos para as aplica√ß√µes clientes, como por exemplo o servidor
REST, e (2) conex√µes de sa√≠da (Output), denominados na maioria das
vezes como streams, que s√£o as conex√µes com os m√≥dulos f√≠sicos (hardware)
e que implementam o protocolo de baixo n√≠vel, realizando a serializa√ß√£o
e desserializa√ß√£o dos comandos enviadas pelas aplica√ß√µes. 

\section{M√≥dulos Servidores \label{subsec:ConexoesServidores}}

Os m√≥dulos servidores, s√£o respons√°veis por fazer a interface com
as aplica√ß√µes clientes. Eles permitem a inclus√£o de novos mecanismos
de conex√£o ou novos protocolos. Um exemplo de utiliza√ß√£o de novo protocolo
√© encontrado no servidor REST, que expande o protocolo do OpenDevice
(\ref{subsec:Protocolo}), permitindo criar interfaces mais simples
e de mais alto n√≠vel para as aplica√ß√µes cliente se comunicarem com
os dispositivos.

O servidor WebSocket permite que aplica√ß√µes (Web, Desktop, Mobile)
se comuniquem em tempo real e de forma bidirecional com os dispositivos,
usando middleware. O framework √© projetado seguindo dois conceitos
de conex√µes: (1) conex√µes de entrada (Input), que s√£o os servidores,
e (2) conex√µes de sa√≠da (Ouput), que s√£o as conex√µes com os dispositivos
f√≠sicos. O papel do middleware √© realizar a tradu√ß√£o dos protocolos
de entrada e converte-los para os protocolos de sa√≠da, espec√≠ficos
para cada dispositivo, confirme a figura \ref{fig:middleware_connections}.
O m√≥dulo de visualiza√ß√£o (com gr√°ficos e dashboards), apresentado
na se√ß√£o \ref{sec:Visualizacao}, utilizam as conex√µes em WebSocket
para permitir a comunica√ß√£o em tempo-real com os dispositivos.

Os servidores permitem a abstra√ß√£o e desacoplamentos entre dispositivos
e aplica√ß√µes, de modo que uma aplica√ß√£o pode se comunicar com v√°rios
dispositivos, ou permitir que varias aplica√ß√µes se comuniquem com
o mesmo dispositivo, contornando alguns problemas das conex√µes que
suportam apenas um cliente, como no caso do Bluetooth e USB.

Os servidores foram projetados pensando na otimiza√ß√£o de recursos
do hardware. Como o objetivo √© permitir que eles possam executar em
hardwares, na categoria Mini-PCs, como o Raspberry e BeagleBone, as
implementa√ß√µes dos servidores utilizados no middleware, foram escolhidas
de modo que rodassem de forma embarcada e compartilhado o m√°ximo de
recursos poss√≠veis. Devido a arquitetura estar projetada para suportar
inicialmente os protocolos HTTP, Rest, WebSocket e MQTT, a implementa√ß√µes
dos mesmos seriam um desafio, devido a variedade de requisitos, estaria
fora do escopo da proposta deste trabalho. Foi ent√£o realizado um
estudo que mapeou as implementa√ß√µes desses protocolos individualmente,
e observou-se que as solu√ß√µes mais maduras estavam baseadas em frameworks
de rede. Os principais frameworks encontrados foram: Jetty (Eclipse)\footnote{http://www.eclipse.org/jetty/},
Grizzly (GlassFish)\footnote{https://grizzly.java.net} e Netty\footnote{http://netty.io}.
O Jetty √© um cont√™iner de aplica√ß√µes Java e servidor web, que tem
uma estrutura modular e suporta protocolos como Http e WebSocket.
Apesar ser poss√≠vel executar de forma embarcada, sua estrutura foi
planejada para executar aplica√ß√µes Java web (.war), n√£o como um framework
gen√©rico e nem com plataformas embarcadas em mente. O Grizzly por
sua vez √© projetado como um framework, e utilizado como base na constru√ß√£o
do servidor de aplica√ß√£o GlassFish, suportando tamb√©m HTTP, WebSocket
e sendo de f√°cil extens√£o. Por fim, o Netty, √© tamb√©m um framework
que tem uma estrutura simples, √© utilizado para constru√ß√£o de projetos
como Apache Spark, Elasticsearch, Neo4j (banco de dados), Minecraft
e outros\footnote{http://netty.io/wiki/adopters.html}. O Netty √©
framework utilizado como base das implementa√ß√µes dos servidores escolhidos
para o projeto arquitetura. 

A escalabilidade da arquitetura pode ser alcan√ßada, substituindo os
implementa√ß√µes dos servidores embarcados, por implementa√ß√µes mais
robustas, que permitam escalonamento horizontal e balanceamento de
carga. Isto pode ser alcan√ßado, de forma transparente para a aplica√ß√£o,
utilizando os mecanismos de extens√£o (\ref{subsec:VisaoGeral-Extensibilidade},
\ref{sec:MecanismoExtensao}).

\begin{figure}
\begin{centering}
\includegraphics[width=0.8\linewidth]{Imagens/Cap_4/middleware_connections}
\par\end{centering}
\caption{Abstra√ß√£o dos protocolos de comunica√ß√£o\label{fig:middleware_connections}}
\end{figure}


\subsection{Servidor MQTT}

A implementa√ß√£o de servidor MQTT escolhida, foi o ``Moquette MQTT'',
projeto mantido pela funda√ß√£o Eclipse, e que utiliza como base o framework
de rede Netty.

Os servidores s√£o em sua maioria destinados √† comunica√ß√£o com as aplica√ß√µes
clientes (conex√µes de entrada). O MQTT √© uma exce√ß√£o, pois permite
que os dispositivos f√≠sicos tamb√©m sejam conectados ao middleware.
Para permitir um gerenciamento e integra√ß√£o com o middleware, e permitir
a comunica√ß√£o bidirecional entre aplica√ß√µes e dispositivos f√≠sicos,
algumas conven√ß√µes foram adotadas na nomenclaturas dos t√≥picos. 

Tanto as aplica√ß√µes como os dispositivos f√≠sicos s√£o ``publish''
e ``subscriber''. O middleware √© o encarregado de monitorar as mensagens
e fazer o direcionamento adequado, atuando como esp√©cie de ``subscriber''
geral. Caso uma aplica√ß√£o envie uma requisi√ß√£o para um dispositivo,
√© papel do middleware fazer o direcionamento para o t√≥pico correto,
e monitorar a resposta e envia-la de volta (publish) para a aplica√ß√£o
que fez a requisi√ß√£o. A camada das aplica√ß√µes n√£o conhecem a estrutura
de t√≥picos do borker MQTT e seu mapeamento para os dispositivos, elas
apenas possuem as abstra√ß√µes dos dispositivos, orientadas a objetos,
e enviam os comandos para o middleware (ex.: device.on()). Isso mermite
que aplica√ß√µes clientes MQTT consigam se comunicar com dispositivos
Bluetooth e MQTT de forma transparente.

A tabela \ref{tab:mqtt_nomenclatura}, apresenta as nomenclaturas
estabelecias para o nome dos t√≥picos. Quando uma aplica√ß√£o realiza
uma opera√ß√£o na abstra√ß√£o do dispositivo (ex.: device.on()), um comando
√© enviado para t√≥pico ``ProjectID/middeware/in'', que √© o canal
que o middleware usa para o recebimento dos comandos das aplica√ß√µes.
Na implementa√ß√£o atual, por ser embarcada, o recebimento √© feito diretamente
sem necessidade do middleware se inscrever nos t√≥picos. O middleware
identifica o dispositivo e determina qual conex√£o que o dispositivo
em quest√£o est√° vinculado, que pode ser uma conex√£o Bluetooth ou MQTT,
nesse ultimo caso, o firmware envia (publish) o comando para seu respectivo
t√≥pico: ``ProjectID/in/ModuleName''.

O componente denominado ``Firmware'' √© um hardware (ex.: arduino)
que pode estar gerenciando um ou mais dispositivos (sensores e atuadores),
onde internamente cada um recebe uma identifica√ß√£o (DeviceID). Cada
conex√£o com um hardware recebe uma identifica√ß√£o chamada ``ModuleName''.

\begin{table}[h]
\begin{centering}
\begin{tabular}{|c|c|c|c|}
\hline 
Componente & Opera√ß√£o & T√≥pico & Descri√ß√£o\tabularnewline
\hline 
\hline 
Firmware & Publish & ProjectID/out & Envio de Dados\tabularnewline
\hline 
Firmware & Subscribe & ProjectID/in/ModuleName & Recebimento de comandos\tabularnewline
\hline 
Middleware & Subscribe{*} & ProjectID/out & {*} Monitoramento (Listener)\tabularnewline
\hline 
Middleware & Subscribe{*} & ProjectID/middeware/in & {*} Monitoramento (Listener)\tabularnewline
\hline 
App & Publish & ProjectID/middeware/in & Envio de Comandos\tabularnewline
\hline 
App & Subscribe & ProjectID/middeware/out & Notifica√ß√µes Gerais\tabularnewline
\hline 
App & Subscribe & ProjectID/middeware/out/CID & T√≥pico de Resposta\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Nomenclatura de t√≥picos MQTT\label{tab:mqtt_nomenclatura}}
\end{table}


\subsection{Servidores WebSocket, Rest e Http}

O WebSocket √© o protocolo originalmente utilizado para permitir a
comunica√ß√£o em tempo-real com as aplica√ß√µes Web, por√©m √© poss√≠vel
a sua utiliza√ß√£o em aplica√ß√µes Desktop. A implementa√ß√£o desse protocolo
√© fornecida pelo projeto Nettosphere\footnote{https://github.com/Atmosphere/nettosphere},
tamb√©m baseado no framework Netty. O grande diferencial √© que ele
oferece a implementa√ß√£o dos tr√™s protocolos utilizando a mesma porta
(ex.: 80), e consequentemente poupando muitos recursos do hardware.
Isso √© poss√≠vel devido a estrutura de processamento do framework Netty,
que permite identificar e processar cada protocolo separadamente.
Teoricamente o mesmo poderia ser feito para o protocolo MQTT, mas
seria um desafio atingir o n√≠vel de maturidade da implementa√ß√£o embarcada
que adotamos.

O servidor HTTP, permite a configura√ß√£o de pastas de recursos como
HTML, CSS e imagens, permitindo a cria√ß√£o de interfaces gr√°ficas.

O servidor REST, permite a cria√ß√£o de servi√ßos que atendem ao protocolo
REST. A integra√ß√£o com o Jesey\footnote{https://jersey.java.net},
permite a implementa√ß√£o da especifica√ß√£o Java \emph{(JAX-RS - The
Java API for RESTful Web Services}), facilitando e padronizando a
cria√ß√£o de novos servi√ßos, estendendo as capacidades do \emph{middleware}.
Os servi√ßos Rest criados, contam com suporte a inje√ß√£o de depend√™ncias,
seguindo a especifica√ß√£o JSR-330, que se utilizam das anota√ß√µes \emph{@Inject
e @Named}, para inje√ß√£o dos componentes.

\section{Suporte a JavaScript\label{subsec:SuporteJavaScript}}

O suporte a JavaScript permite a cria√ß√£o de aplica√ß√µes simples e tratadores
de eventos, que rodam nativamente, e √© integrado ao OpenDevice atrav√©s
do mecanismo de extens√µes. Tamb√©m √© poss√≠vel criar aplica√ß√µes Web,
utilizando JavaScript, com aux√≠lio da biblioteca \noun{opendevice-js,
}que permite a abstra√ß√£o dos dispositivos e implementa os protocolos
REST e WebSocket.

No primeiro caso, √© poss√≠vel criar aplica√ß√µes que executa nativamente,
ou seja, sem depender de um navegador, pois rodam diretamente na JVM,
Este suporte √© fornecido atrav√©s do m√≥dulo \noun{js-engine}, que usa
os recursos da pr√≥pria JVM implementados no projeto Nashorn \footnote{http://openjdk.java.net/projects/nashorn/}.
Este recurso auxilia na sua utiliza√ß√£o por desenvolvedores que n√£o
t√™m experi√™ncia com linguagem Java ou mesmo desenvolvedores experientes
que precisam realizar uma prototipa√ß√£o mais r√°pida ou pela simplicidade
da implementa√ß√£o de tratamento de eventos com uma linguagem de script.
Devido a necessidade de recursos avan√ßados da JVM, esse m√≥dulo (\noun{js-engine})
depende da vers√£o Java 8, que inclui v√°rias melhorias de performance
e integra√ß√£o com JavaScript. Os modos de desenvolvimento ser√£o detalhados
a seguir.

\subsection{Cria√ß√£o de aplica√ß√µes nativas em JavaScript}

As aplica√ß√µes criadas em JavaScript, executam na JVM e t√™m interoperabilidade
com as classes definidas em Java. Desse modo √© poss√≠vel realizar chamadas
nas classes e m√©todos do OpenDevice. A listagem \ref{alg:ExemploJS1},
demonstra um exemplo de cria√ß√£o de uma aplica√ß√£o simples, que ao detectar
uma mudan√ßa no bot√£o~(BUTTON), controla o estado da l√¢mpada~(led).
O m√≥dulo \noun{js-engine} pode ser compilado para um execut√°vel (odevjs.exe
ou odevjs.jar), destinado a execu√ß√£o de aplica√ß√µes em JavaScript usando
o comando: \inputencoding{latin9}\lstinline!> odevjs.exe myscript.js!\inputencoding{utf8}.

Outro exemplo de aplica√ß√£o, usando interface gr√°fica (GUI) em JavaFX,
pode ser encontrado no Ap√™ndice \ref{chap:ApendiceA}. Para habilitar
o JavaFX √© necess√°rio informar o par√¢metro ``-fx'', exemplo: \inputencoding{latin9}\lstinline!> odevjs.exe -fx myscript.js!\inputencoding{utf8}.
Os c√≥digos JS podem ser executados diretamente de aplica√ß√µes Java,
atrav√©s da classe \emph{OpenDeviceJSEngine}, exemplo: \inputencoding{latin9}\lstinline!OpenDeviceJSEngine.run("myscript.js")!\inputencoding{utf8}.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}
var led = new Device(1, DIGITAL);
var button = new Sensor(2, DIGITAL);

button.onChange(function(){
    if(button.isON()){
        led.on();
    }else{
        led.off();
    }
});

connect(usb());
\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplo de Aplica√ß√£o em JavaScript\label{alg:ExemploJS1}}

\end{algorithm}


\subsection{Tratadores de Eventos (EventHook)}

Os tratadores de evento (EventHook), s√£o pequenos trechos de c√≥digo
JavaScript que est√£o vinculados os dispositivos (Devices e Sensors)
e s√£o executados quando acontece alguma mudan√ßa do seu valor. Esse
mecanismo √© uma extens√£o para o EventManager, e implementada pela
classe \emph{JavaScriptEventHandler}. A implementa√ß√£o padr√£o faz o
carregamento dos scripts atrav√©s de arquivos, mas pode-se implementar
outras formas de armazenamento/carregamento. Na implementa√ß√£o atual
os eventos s√£o mapeados para os dispositivos atrav√©s de metadados
inclu√≠dos no pr√≥prio script. Na listagem \ref{alg:ExemploJS2}, √©
implementado a mesma l√≥gica da listagem \ref{alg:ExemploJS1}, entretanto,
eles n√£o s√£o interpretados atrav√©s do execut√°vel (odevjs.exe), eles
s√£o gerenciados pelo middleware e s√£o executados quando os dispositivos
mapeados atrav√©s da anota√ß√£o \noun{@devices,} sofrem alguma modifica√ß√£o.
A vari√°vel ``device'', √© injetada pelo framework e representa o
dispositivo que sofreu a altera√ß√£o.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language=VBScript]
/**
 * @name ButtonHookDemo
 * @devices 2
 * @description TestCase
 * @type JavaScript
 */
var led = findDevice(1);
if(device.isON()){
    led.on();
}else{
    led.off();
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplo do ``EventHook'' em JavaScript\label{alg:ExemploJS2}}
\end{algorithm}


\subsection{Cria√ß√£o de aplica√ß√µes WEB em JavaScript}

A biblioteca \noun{opendevice-js} foi desenvolvida para auxiliar no
desenvolvimento de aplica√ß√µes Web escritas em qualquer outra linguagem,
e sua integra√ß√£o com os dispositivos f√≠sicos. Ela permite a comunica√ß√£o
em tempo real com os dispositivos gra√ßas ao suporte a WebSocket. Trabalha
no modelo orientado a eventos, ou seja, quando ocorre alguma mudan√ßa
no estado no dispositivo, o evento ``\emph{onChange}'' √© chamado,
conforme no exemplo na listagem \ref{alg:ExemploJS3}. Ela √© utilizada
na constru√ß√£o do \emph{Front-End Web} do middleware (\ref{sec:Visualizacao}),
que permite fazer o controle dos dispositivos, realizar a an√°lise
e visualiza√ß√£o de dados em tempo-real ou de dados hist√≥ricos. 

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language=VBScript]
<script>
    $(function(){ // JQuery ready()
        ODev.connect();
    });

    ODev.onChange(function(device){
        if(device.sensor){
            ODev.findDevice(1).setValue(device.value);
        }
    });
</script>
\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplo de utiliza√ß√£o da biblioteca \noun{opendevice-js}\label{alg:ExemploJS3}}
\end{algorithm}


\section{Visualiza√ß√£o e controle dos dispositivos\label{sec:Visualizacao}}

O middleware conta uma uma interface Web (figura \ref{fig:dashboard1}
e \ref{fig:dashboard2}), desenvolvida em HTML5 e AngularJS, e √© implementado
pelo m√≥dulo \noun{opendevice-web-view, }que permite o monitoramento,
controle dos dispositivos e visualiza√ß√£o do dados atrav√©s de gr√°ficos
e indicadores. A visualiza√ß√£o pode ser em tempo-real ou atrav√©s de
consultas a dados hist√≥ricos. √â poss√≠vel aplicar fun√ß√µes como: (1)
m√©dia, (2) m√≠nimo, 3 (m√°ximo), 4 (soma), 5 (contagem) e 6 (desvio
padr√£o), nos dados de um determinado intervalo que √© configurado via
a interface gr√°fica. Os gr√°ficos implementados s√£o: (1) gr√°fico de
linha, (2) gr√°fico de pizza, (3) gauge e (4) indicador num√©rico. Os
\emph{dashboards} s√£o altamente flex√≠veis, permitindo configurar o
tamanho, adicionar e remover gr√°ficos. Alguns gr√°ficos permitem a
inclus√£o de v√°rios dispositivos, permitindo uma an√°lise comparativa,
como no exemplo da figura \ref{fig:dashboard2} (Luz Semana 1), foram
inclu√≠dos tr√™s dispositivos em um gr√°fico de linha. O mesmo permite
fun√ß√µes de zoom em determinado per√≠odo de forma interativa. Os dashboards
permitem tamb√©m a inclus√£o de dispositivos e sensores digitais, permitindo
o controle, ativa√ß√£o, desativa√ß√£o e visualiza√ß√£o do status atual.

\begin{figure}[H]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/dashboard-devices}
\par\end{centering}
\caption{Interface de controle de dispositivos\label{fig:dashboard1}}
\end{figure}

\begin{figure}[H]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/dashboard-charts}
\par\end{centering}
\caption{Interface de Dashboards Gr√°ficos\label{fig:dashboard2}}
\end{figure}


\section{Servi√ßo de descoberta\label{sec:ServicoDescoberta}}

Conectar e configurar um dispositivo (microcontrolador, sensor ou
atuador), √© uma tarefa relativamente simples. Fazer o mesmo para centenas
ou milhares de dispositivos, n√£o √© uma tarefa f√°cil. Este √© o cen√°rio
que os pesquisadores e desenvolvedores ir√£o encontrar no ambiente
de Internet das Coisas. Um mecanismo din√¢mico, adapt√°vel e utilizando
um processo mais automatizado poss√≠vel, √© necess√°rio para realizar
a descoberta de dispositivos e registro de suas informa√ß√µes b√°sicas.
Al√©m disso existe a necessidade de trabalhar de forma unificada com
diferentes protocolos e dispositivos de rede.

O framework conta com servi√ßos de descoberta de dispositivos, suportando
as tecnologias Usb, Bluetooth, Ethernet e Wi-Fi. O middleware tamb√©m
disponibiliza um servi√ßo de descoberta, permitindo que as aplica√ß√µes
clientes o localizem em uma rede local. S√£o dois os poss√≠veis cen√°rios
onde as aplica√ß√µes e dispositivos IoT estar√£o executando: Local e
Internet. No cen√°rio onde os dispositivos est√£o conectados √† Internet,
eles devem ser configurados para atuarem como clientes, conectando-se
no servidor em nuvem do OpenDevice em um endere√ßo fixo. J√° em um cen√°rio
local, focando-se em dispositivos Ethernet, no cen√°rio de automa√ß√£o
residencial, por exemplo, os dispositivos poderiam atuar em modo cliente
ou como servidor, em ambos os cen√°rios seria necess√°rio configurar
manualmente um IP fixo para cada dispositivo, uma tarefa relativamente
trabalhosa dependendo da quantidade de dispositivos.

Uma solu√ß√£o promissora √© o padr√£o DNS-SD (DNS Service Discovery, RFC
6763) \cite{key-dnssd}, que permite a descoberta de servi√ßos na rede
e associa√ß√£o de um ``DNS local'' para o dispositivo, como por exemplo:
\emph{lampada1.local}. Devido √†s limita√ß√µes de alguns hardwares alvos
do estudo (microcontroladores), uma solu√ß√£o mais simples foi adotada.
Trata-se do envio de mensagens UDP em broadcast na rede. Os dispositivos
(hardware) monitoram a rede e ao detectar uma solicita√ß√£o de descoberta
(um comando do tipo \emph{DISCOVERY\_REQUEST}), enviam uma mensagem
de volta contendo o seu nome, tipo, IP atual, e porta. Desse modo,
todos os dispositivos podem ser configurados com IP din√¢mico usando
DHCP, incluindo o pr√≥prio servidor (middleware). As aplica√ß√µes clientes
podem localizar os dispositivos ou middleware utilizando o mesmo mecanismo. 

Foi desenvolvida uma estrat√©gia bastante simples, influenciada pelo
DNS-SD e combinado com a t√©cnica desenvolvida, para conex√£o com os
dispositivos TCP/IP, usando um endere√ßo com sufixo pr√©-definido (ex.:
\emph{lampada1}.local.opendevice). A listagem \ref{alg:descoberta}
apresenta um modelo tradicional de descoberta e o modelo usando os
endere√ßos de dom√≠nio local. No primeiro exemplo (modelo tradicional)
√© obtido o servi√ßo de descoberta e iniciado a busca durante 5 segundos
por dispositivos na rede, em seguida √© feita a conex√£o. No segundo
exemplo, ele permite a simplifica√ß√£o do processo. O endere√ßo informado
``lampada1.local.opendevice'', na verdade n√£o se trata de um dom√≠nio,
serve apenas para marcar e iniciar o sistema de descoberta autom√°tico,
permitindo uma f√°cil conex√£o com determinado dispositivo (hardware).
A imagem \ref{fig:DiagDiscoveryConnect} apresenta um diagrama de
fluxo de como esse processo funciona.

As conex√µes USB e Bluetooth, possuem mecanismos de descobertas menos
sofisticados, oferecidos pelas pr√≥prias implementa√ß√µes no S.O, que
s√£o usados pelo servi√ßo de descoberta. No caso do USB, a classe que
implementa essa conex√£o (\emph{UsbConnection}), possui o m√©todo ``listAvailable'',
que lista todos os dispositivos USB-Serial conectados na maquina.
√â poss√≠vel realizar facilmente uma conex√£o com o primeiro dispositivo
encontrado usando: \inputencoding{latin9}\lstinline!connect(out.usb())!\inputencoding{utf8}.
A implementa√ß√£o para Bluetooth √© similar, onde o m√©todo ``listAvailable''
da classe (\emph{BluetoothConnection}), realiza a listagem dos dispositivos
seriais SSP - (Serial Port Profile) dispon√≠veis, tamb√©m √© poss√≠vel
conectar-se facilmente com o primeiro dispositivo encontrado, usando:
\inputencoding{latin9}\lstinline!connect(out.bluetooth())!\inputencoding{utf8}
(observe que, antes √© necess√°rio realizar manualmente o pareamento
dos dispositivos). 

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
// Modelo tradicional
Set<NetworkDeviceInfo> devices = getDiscoveryService().scan(5000, null);
if(devices.size() > 0){
    NetworkDeviceInfo info = devices.iterator().next();
    if(info.getName().equals("lampada1")) {
        connect(out.tcp(info.getIp() + ":" + info.getPort()));
    }
}

// Modelo usando domÌnio local
connect(out.tcp("lampada1.local.opendevice"));
\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplos de descoberta de dispositivos \label{alg:descoberta}}
\end{algorithm}

\begin{figure}
\begin{centering}
\includegraphics[width=0.8\linewidth]{Imagens/Cap_4/seq_discovery_connect}
\par\end{centering}
\caption{Fluxo de conex√£o e descoberta\label{fig:DiagDiscoveryConnect}}
\end{figure}


\section{APIs para Aplica√ß√µes Cliente\label{subsec:ConexoesCliente}}

O conjunto de bibliotecas ou APIs para aplica√ß√µes clientes, permitem
a r√°pida constru√ß√£o de aplica√ß√µes, sem que os pesquisadores ou desenvolvedores
tenham que se preocupar com os detalhes de baixo n√≠vel do protocolo,
adotando um modelo orientado a eventos (\emph{Event-Driven}) e usando
orienta√ß√£o a objetos na constru√ß√£o das aplica√ß√µes, que podem ser aplica√ß√µes
Web, Desktop, Mobile ou uma interface simula√ß√£o. O maior desafio encontrado
na constru√ß√£o dessas aplica√ß√µes √© lidar com a heterogeneidade dos
dispositivos (atuadores e sensores), fazer o gerenciamento das conex√µes
e a integra√ß√£o com a aplica√ß√£o. A arquitetura disponibiliza um middleware
e um framework para constru√ß√£o aplica√ß√µes ou middleware customizadas.

As bibliotecas disponibilizadas permitem uma comunica√ß√£o bidirecional
e s√£o focadas na comunica√ß√£o em tempo real, dessa maneira √© poss√≠vel
construir gr√°ficos para visualiza√ß√£o das informa√ß√µes em tempo-real,
aplica√ß√µes de simula√ß√£o, etc. As tecnologias empregadas que permitem
essa comunica√ß√£o, est√£o dispon√≠veis para as plataformas Web, Desktop
e Mobile, conforme a tabela \ref{tab:apis-clientes}.

\begin{table}[h]
\begin{centering}
\begin{tabular}{|c|c|c|c|c|}
\hline 
Tipo & Web & Desktop & Mobile (Android) & Alvo de Comunica√ß√£o\tabularnewline
\hline 
\hline 
USB &  & X &  & Firmware\tabularnewline
\hline 
Bluetooth &  & X & X & Firmware\tabularnewline
\hline 
Socket (TCP) &  & X &  & Middleware/Firmware\tabularnewline
\hline 
WebSocket & X & X & X & Middleware\tabularnewline
\hline 
MQTT &  & X & X & Middleware\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{APIs Clientes\label{tab:apis-clientes}}
\end{table}


\subsection{Implementa√ß√£o}

A maior parte das bibliotecas s√£o implementados em linguagem Java
com base no framework de conex√µes (\ref{subsec:Framework-de-Conexoes})
e utilizam o m√≥dulo principal (core), que prov√™ as APIs de comandos
e abstra√ß√£o de dispositivos. Por√©m s√£o disponibilizadas bibliotecas
em JavaScript, apresentada na se√ß√£o \ref{subsec:SuporteJavaScript},
e Python (experimental). As tecnologias de comunica√ß√£o (ex.: USB),
s√£o implementadas com aux√≠lio de bibliotecas externas, e suas considera√ß√µes
s√£o listadas a seguir.

\subsubsection{USB}

A comunica√ß√£o USB, por utilizar recursos do sistema operacional e
ser dependente da arquitetura, n√£o possui suporte nativo na JVM, apesar
de ser umas das especifica√ß√µes iniciais da plataforma, registrada
sobre a especifica√ß√£o Java USB API (JSR-80)\cite{key-JSR-80}.

Como alternativa, algumas bibliotecas de terceiros foram avaliadas.
Uma das pioneiras e mais utilizadas √© a biblioteca RXTX\footnote{https://github.com/rxtx/rxtx}.
Esta biblioteca foi utilizada nas vers√µes iniciais da plataforma,
por√©m, pelo fato de n√£o ter um desenvolvimento ativo, e nos testes
realizados ter se mostrado inst√°vel, apresentando alguns erros (ex.:
problemas de deadlocks e mal funcionamento em plataformas ARM), ela
foi substitu√≠da.. A implementa√ß√£o de refer√™ncia oficial, javax-usb
\footnote{http://javax-usb.sourceforge.net/}, a julgar pelo site
e documenta√ß√£o, est√£o abandonados h√° muito tempo.

A implementa√ß√£o utilizada, foi baseada na biblioteca JSSC (Java Simple
Serial Connector)\footnote{https://github.com/scream3r/java-simple-serial-connector},
que oferece suporte para v√°rias plataformas\footnote{Segundo o site: Windows(x86, x86-64), Linux(x86, x86-64, ARM soft
\& hard float), Solaris(x86, x86-64), Mac OS X(x86, x86-64, PPC, PPC64)}, se mostrando uma alternativa promissora. Ela √© a biblioteca utilizada
na IDE do Arduino, substituindo a RXTX em vers√µes anteriores.


\subsubsection{Bluetooth}

A comunica√ß√£o Bluetooth √© apoiada na especifica√ß√£o Java JSR-82\cite{key-JSR-82},
possui implementa√ß√µes bem estabelecidas e est√°veis para o desenvolvimento
para dispositivos m√≥veis, usando JavaME. As implementa√ß√µes para ambiente
desktop, sofrem com os mesmos problemas de plataforma do USB. Uma
das poucas alternativas, √© a biblioteca BlueCove\footnote{http://bluecove.org/},
que tem implementa√ß√µes para os principais sistemas operacionais (Windows,
Linux, MacOS). Para o suporte √† plataformas ARM (no RaspberryPi),
foi necess√°rio a recompila√ß√£o da mesma e ajustes, pois n√£o foram encontradas
vers√µes disponibilizadas no site oficial nem de terceiros. 

As implementa√ß√µes para aplica√ß√µes mobile, est√£o dispon√≠veis para o
Android, e utiliza as APIs disponibilizadas pela pr√≥pria plataforma.
A arquitetura do OpenDevice, √© projetada de maneira que a implementa√ß√£o
utilizada √© transparente para o desenvolvedor, sem precisar de modifica√ß√µes
no c√≥digo.

\subsubsection{Socket (TCP)}

Foi implementada usando as APIs nativas do Java, usando as classes
da API de Socket. Devido o Java ser projetado para constru√ß√£o de sistemas
em rede, as APIs de comunica√ß√£o s√£o suportadas em praticamente todas
as plataformas.

Apesar de ser compat√≠vel com as plataformas mobile (Android), a implementa√ß√£o
atual n√£o √© indicada, por n√£o levar em considera√ß√£o requisitos de
consumo de bateria.

\subsubsection{WebSocket}

A implementa√ß√£o de WebSocket para plataforma Web utiliza as pr√≥prias
APIs disponibilizadas pelos navegadores, atrav√©s da implementa√ß√£o
da especifica√ß√£o de WebSocket para o HTML5\cite{key-ws-1,key-ws-2}.

A implementa√ß√£o para aplica√ß√µes Desktop e Mobile(Android), s√£o baseadas
na biblioteca wAsync\footnote{https://github.com/Atmosphere/wasync}.
As especifica√ß√µes da API de WebSocket para plataforma Java, est√£o
dispon√≠veis atrav√©s da especifica√ß√£o JSR 356\cite{key-JSR-356}, e
uma implementa√ß√£o de refer√™ncia chamada Tyrus\footnote{https://tyrus.java.net/},
se mostra promissora, por√©m ainda conta com limita√ß√µes para utiliza√ß√£o
no Android e por conta disso n√£o foi utilizada.


\section{Armazenamento\label{sec:Armazenamento}}

O sistema de armazenamento guarda informa√ß√µes sobre as conex√µes, dispositivos
e hist√≥rico de dados. A implementa√ß√£o padr√£o √© baseada em um banco
de dados orientado a grafos, chamado Neo4j\footnote{http://www.neo4j.com},
baseado no conceito NoSQL, que permite ser executado de forma embarcada,
junto com a aplica√ß√£o. A base da arquitetura do Neo4j √© constru√≠da
usando o framework Netty, o mesmo utilizado nas implementa√ß√µes dos
m√≥dulos de servidores (\ref{subsec:ConexoesServidores}), permitindo
otimizando alguns recursos de espa√ßo e consumo de mem√≥ria. Ao incluir
o middleware e o m√≥dulo de interface gr√°fica, as informa√ß√µes sobre
os \emph{dashboards} e configura√ß√£o dos gr√°ficos tamb√©m s√£o armazenadas.
Na constru√ß√£o de aplica√ß√µes e prot√≥tipos, o sistema de armazenamento
pode ser dispensado, usando apenas o sistema de cache de dispositivos,
por√©m este n√£o permite a visualiza√ß√£o de dados hist√≥ricos. 


\section{Firmware\label{subsec:Arquitetura-do-Firmware}}

O firmware √© um componente que permite a cria√ß√£o de dispositivos (coisas)
para Internet das Coisas. Ele foi projetado para cria√ß√£o de sistemas
embarcados para microcontroladores, e se baseia na API do Arduino
para acesso aos perif√©ricos do microcontrolador. Apesar de utilizar
a API do Arduino, ele n√£o est√° limitado apenas aos \emph{hardwares}
denominados Arduino. V√°rias outras plataformas vem implementando o
suporte a sua API\cite{arduino-comp1,arduino-comp3}, como por exemplo
o ESP8266\cite{url:esp8266:espressif}, um SoC (System-On-Chip) de
32 bits com Wi-Fi embutido. Hardwares com maior poder de processamento
e que suportem a execu√ß√£o na JVM (M√°quina Virtal Java), n√£o far√£o
utiliza√ß√£o do firmware.

O firmware √© flex√≠vel e pode ser utilizado como base para cria√ß√£o
sistemas embarcados customizados, dando suporte a v√°rias tecnologias
de comunica√ß√£o, como: Usb, Bluetooth, Ethernet e Wi-Fi, que pode operar
tanto no modo cliente como no modo servidor (vide tabela \ref{tab:FirmwareConexoes}).
Dentro da plataforma do Arduino ele √© disponibilizado como uma biblioteca
escrita em C++, e √© respons√°vel pelo gerenciamento dos dispositivos,
conex√µes e implementa o protocolo do OpenDevice. 


\subsection{Vis√£o Geral}

Na figura \ref{fig:ArquiteturaFirmware} √© apresentada uma vis√£o geral
de como a arquitetura do \emph{firmware} est√° estruturada. Podemos
observar que ela √© similar a arquitetura geral do projeto (Figura
\ref{fig:Arquitetura}), a camada central, que compreende o firmware,
√© a jun√ß√£o das bibliotecas do Arduino, APIs do OpenDevice e o c√≥digo
do usu√°rio (\emph{User Code}), que auxiliam na cria√ß√£o dos sistemas
embarcados. A camada superior, compreende as aplica√ß√µes cliente, que
implementam os protocolos de baixo n√≠vel (\ref{subsec:Protocolo}),
com aux√≠lio das bibliotecas disponibilizadas pelo OpenDevice.

\begin{figure}
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/arquitetura-firmware}
\par\end{centering}
\caption{Arquitetura do Firmware\label{fig:ArquiteturaFirmware}}
\end{figure}


\subsection{Meios de comunica√ß√£o suportados}

A tabela \ref{tab:FirmwareConexoes} apresenta as tecnologias de comunica√ß√£o
que s√£o suportadas, destacadas juntos com os modelos de comunica√ß√£o.
Entende-se por modelo de comunica√ß√£o a forma como o firmware ir√° operar,
se √© no modo cliente ou no modo servidor.

\begin{table}[h]
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Tipo & Cliente & Servidor\tabularnewline
\hline 
\hline 
Usb & N√£o & Sim\tabularnewline
\hline 
Bluetooth & N√£o & Sim\tabularnewline
\hline 
Ethernet & Sim & Sim\tabularnewline
\hline 
Wi-Fi & Sim & Sim\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Comunica√ß√£o suportada pelo firmware\label{tab:FirmwareConexoes}}

\end{table}


\subsection{Gerenciamento de conex√µes\label{subsec:FirmwareGerenciamentoConn}}

O bloco denominado ``Connections Framework'', trata-se de adapta√ß√µes
das bibliotecas disponibilizadas pelo Arduino (``User Libs'' e nativas)
para implementa√ß√£o das conex√µes, usando seus respectivos m√≥dulos m√≥dulos
(shields), permitindo assim a comunica√ß√£o com o middleware e aplica√ß√µes.
Por exemplo, o suporte a conex√µes Ethernet usando o m√≥dulo ENC28J60,
necessita de uma biblioteca espec√≠fica que realiza a implementa√ß√£o
do protocolo TCP/IP via software, j√° o modulo(shield) Ethernet baseado
no chip W5100 √© suportado nativamente pelo framework do Arduino e
OpenDevice. O Arduino disponibiliza uma API base para implementa√ß√£o
das conex√µes Ethernet e Wi-Fi. M√≥dulos (shields) que implementem essa
API estariam compat√≠veis automaticamente com o OpenDevice. 

As conex√µes USB e Bluetooth, s√£o comunica√ß√µes seriais, acess√≠veis
atrav√©s de portas UART, referenciadas geralmente pelas vari√°veis
\emph{Serial}, \emph{Serial1}, etc. E que t√™m como implementa√ß√£o base
a classe \emph{Stream}(do Arduino). Outras tecnologias de conex√£o,
que se baseiem nos mecanismos apresentados acima ser√£o automaticamente
suportados, ou necessitariam de pequenos ajustes. 

As tecnologias implementadas est√£o listadas na tabela \ref{tab:FirmwareConexoes}
e mais adiante na se√ß√£o de hardwares testados (\ref{par:Hardwares-Testados});

\subsection{Gerenciamento dos dispositivos}

No firmware √© realizado o mapeamento dos dispositivos e seus respectivos
IDs para os pinos do microcontrolador. Ele interpreta os comandos
enviados pelas aplica√ß√µes e as transforma em a√ß√µes. Um exemplo de
mapeamento dos dispositivos √© demonstrado da listagem \ref{alg:firmware1},
onde √© feita a configura√ß√£o de forma est√°tica, adicionando atuadores
e sensores. As classes que abstraem os dispositivos existem, e s√£o
baseados na classe Device, e conta com um atributo do tipo \emph{booleano}
chamado \textquotedbl{}sensor\textquotedbl{}, para identificar se
√© um atuador ou sensor. 

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
#include <OpenDevice.h>
// Mapeamento dos Dispositivos
void setup(){
	ODev.name("ODev-Thing1");
    ODev.addCommand("alertMode", alertMode);
    ODev.addDevice(5, Device::DIGITAL); // ID:1
    ODev.addSensor(3, Device::DIGITAL); // ID:2 
    ODev.addSensor(RFIDSensor(10,9)); // ID:1
    ODev.begin();
}

void loop(){
  ODev.loop();
}
// Comando de Usuario
void alertMode(){
  ODev.debug(ODev.readString());
  int count = ODev.readInt();
  // ....
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplo de configura√ß√£o do firmware\label{alg:firmware1}}
\end{algorithm}


\subsubsection{Dispositivos suportados}

A tabela \ref{tab:FirmwareDevices}, apresenta a lista de dispositivos
suportados nativamente. A extens√£o de dispositivos permite a inclus√£o
e suporte de novos dispositivos, sendo apresentado com mais detalhes
na se√ß√£o \ref{subsec:FirmwareExtensibilidade}.

\begin{table}[h]
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Nome & Tipo & Biblioteca Extra\tabularnewline
\hline 
\hline 
Gen√©rico Digital (1 pino) & Atuador / Sensor & N√£o\tabularnewline
\hline 
Gen√©rico Anal√≥gico (1 pino) & Atuador / Sensor & N√£o\tabularnewline
\hline 
RFID (MFRC522) & Sensor & Sim\tabularnewline
\hline 
Servo Motor & Atuador & N√£o\tabularnewline
\hline 
Temperatura (LM35) & Sensor & N√£o\tabularnewline
\hline 
Infra-Vermelho (Emissor) & Atuador & Sim\tabularnewline
\hline 
Infra-Vermelho (Receptor) & Sensor & Sim\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Dispositivos suportados nativamente\label{tab:FirmwareDevices}}
\end{table}


\subsection{Comandos de Usu√°rio}

Os desenvolvedores podem criar novos comandos, estendendo o protocolo
ou usando os recursos de comandos do usu√°rio (\emph{User Functions},
na figura \ref{fig:ArquiteturaFirmware}). Esse recurso permite criar
novos comandos e vincul√°-los √† fun√ß√µes definidas pelo pr√≥prio usu√°rios.
A listagem \ref{alg:firmware1}, apresenta um exemplo desse recurso.
Os comandos s√£o criados usando a fun√ß√£o ``\inputencoding{latin9}\lstinline!ODev.addCommand!\inputencoding{utf8}'',
definindo o nome e a fun√ß√£o que ser√° executada ao receber esse comando.
No lado da aplica√ß√£o (Java), esse comando √© executado atrav√©s do m√©todo:
``\inputencoding{latin9}\lstinline!sendCommand("alertMode","Your String", 5)!\inputencoding{utf8}''.
Observe que tamb√©m √© poss√≠vel passar par√¢metros para a fun√ß√£o, e no
lado do firmware os par√¢metros podem ser recuperados usando as fun√ß√µes
``\inputencoding{latin9}\lstinline!ODev.read*()!\inputencoding{utf8}''.

\subsection{Mecanismos de leitura de sensores\label{subsec:FirmwareLeituraSensores}}

O mecanismo de leitura adotado, tamb√©m √© um sistema baseado em eventos,
ou seja, as aplica√ß√µes n√£o precisam realizar consultas para obter
os valores dos sensores. Quando houver alguma altera√ß√£o no valor do
sensor, automaticamente o firmware envia o valor atualizado para as
aplica√ß√µes. Internamente, o mecanismo de leitura opera de dois modos:
s√≠ncrono e ass√≠ncrono, que ser√£o apresentados a seguir.

\subsubsection{Modo S√≠ncrono (Polling)}

O mecanismo s√≠ncrono ou ``polling'', √© o mecanismo ativo por padr√£o,
e por ser uma implementa√ß√£o mais simples, pode ser utilizado em qualquer
microcontrolador, por√©m existem algumas limita√ß√µes. Por se tratar
de um mecanismo onde √© preciso realizar uma leitura de todos os sensores(pinos)
configurados, e comparar o valor lido com o valor atual, algum tempo
ser√° perdido lendo sensores que n√£o alteraram seu valor, e consumindo
recursos desnecess√°rios CPU, que poderia estar desempenhando outras
atividades. Dependendo do tempo da leitura dos sensores, alguma informa√ß√£o
importante pode ser perdida. A leitura de pinos digitais e anal√≥gica
√© bem r√°pida, a leitura de um pino anal√≥gico por exemplo, demora cerca
de 100 microssegundos~(0.0001 s), em um processador AVR 8-bits\footnote{https://www.arduino.cc/en/Reference/analogRead}.

\subsubsection{Modo Ass√≠ncrono (Interrup√ß√µes)}

As interrup√ß√µes s√£o sinais enviados para o microcontrolador com eventos
que precisam de imediata aten√ß√£o. A interrup√ß√£o permite que o processador
interrompa a tarefa atual , salve seu contexto, e execute um rotina
especial de interrup√ß√£o, conforme na figura \ref{fig:interrupcoes}.
Quando um dispositivo precisa de aten√ß√£o ele envia um sinal para o
processador que desloca a execu√ß√£o para rotina de interrup√ß√£o (ISR).
O suporte a interrup√ß√£o externas (mudan√ßa nos pinos de I/O), depende
do microcontrolador, alguns suportam interrup√ß√µes em todos os pinos
e outros suportam interrup√ß√µes apenas em alguns pinos predefinidos.
Para citar exemplos, o Arduino DUE (SAM3X8E ARM) possui suporte a
interrup√ß√µes externas em todos os pinos, j√° o Arduino Uno (e similares
com chip ATmega328p) suporta interrup√ß√µes externas apenas nos pinos
2 e 3. 

Para lidar com as limita√ß√µes encontradas, o firmware utiliza uma biblioteca\footnote{https://github.com/GreyGnome/EnableInterrupt}
que permite habilitar a associa√ß√£o de rotinas de interrup√ß√µes individuais
para todos os pinos do microcontrolador, fazendo o gerenciamento do
estado dos pinos. Algumas limita√ß√µes tamb√©m s√£o encontradas nessa
alternativa. O tempo de interrup√ß√£o pode sofrer atrasos na ordem de
alguns micro-segundos para pinos que n√£o suportem nativamente as interrup√ß√µes
externas. Dependendo da aplica√ß√£o isso pode ser relevante. Uma an√°lise
realizada dos tempos de tratamento das interrup√ß√µes, nessa implementa√ß√£o,
√© apresentada em \cite{key-isr}.

Para habilitar o suporte a interrup√ß√µes em um sensor √© preciso habilitar
o recurso nas configura√ß√µes gerais e ativar os sensores que ser√£o
lidos com base nas interrup√ß√µes. Com base no exemplo da listagem \ref{alg:interrupcoes},
quando ocorre alguma interrup√ß√£o nos sensores configurados, os valores
deles s√£o lidos pela rotina \emph{``OpenDeviceClass::onInterruptReceived()}'',
e marcados para sincroniza√ß√£o, que ir√° ocorrer no ciclo de ``loop''.
Um ponto importante √© que os dados n√£o podem ser enviados na rotina
de interrup√ß√£o, pois ela deve ocorrer o mais r√°pido poss√≠vel, evitando
problemas na leitura de outras interrup√ß√µes e podem ocasionar conflitos
com as interrup√ß√µes de leituras das portas seriais. Detalhes de execu√ß√£o
desse fluxo ser√£o apresentados na se√ß√£o \ref{subsec:LeituraSensores}.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
#include <EnableInterrupt.h>
#include <OpenDevice.h>

void setup() {
  // Modo 1
  ODev.addSensor(3, Device::DIGITAL)->enableInterrupt(CHANGE); // ID:1
  // Modo 2
  Device *s2 = ODev.addSensor(4, Device::DIGITAL); // ID:2
  *s2->enableInterrupt(CHANGE);
  
  ODev.begin();
}

void loop() {
  ODev.loop();
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Leitura usando interrup√ß√µes (Arduino/C++) \label{alg:interrupcoes}}
\end{algorithm}

\begin{figure}
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/firmware_interrupcao}
\par\end{centering}
\caption{Execu√ß√£o de uma interrup√ß√£o\label{fig:interrupcoes}}
\end{figure}


\subsection{Configura√ß√£o din√¢mica e parametriza√ß√µes\label{subsec:ConfiguracaoDinamica}}

O firmware tenta detectar o hardware e as bibliotecas utilizadas e
realizar as parametriza√ß√µes necess√°rias, necessitando o m√≠nimo de
configura√ß√µes poss√≠veis. Um exemplo da t√©cnica √© apresentado na listagem
\ref{alg:firmware2}, onde a implementa√ß√£o da Ethernet √© alterada
apenas escolhendo o \emph{``include''} correspondente, sem necessidade
de altera√ß√µes no c√≥digo. As duas implementa√ß√µes s√£o totalmente diferentes,
por√©m essas diferen√ßas s√£o abstra√≠das pelo firmware, permitindo que
o desenvolvedor foque na l√≥gica do sistema.

Algumas parametriza√ß√µes e valores padr√£o, como velocidade, portas,
tamanhos dos \emph{buffers} de recep√ß√£o de dados, podem ser ajustados
no arquivo: ``config.h'', bem como √© poss√≠vel habilitar o modo de
depura√ß√£o (debug), para auxiliar na detec√ß√£o de algum erro que esteja
ocorrendo. As informa√ß√µes de depura√ß√£o podem ser direcionadas para
a conex√£o atual ou para uma porta serial do microcontrolador.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
//#include <UIPEthernet.h> // ENC28J60
#include <Ethernet.h>
#include <OpenDevice.h>

void setup(){
  ODev.addDevice(13, Device::DIGITAL);
  ODev.begin();
}

void loop(){
  ODev.loop();
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplo de configura√ß√£o do firmware\label{alg:firmware2}}
\end{algorithm}


\subsection{Monitoramento}

O sistema de monitoramento permite informar √†s aplica√ß√µes a utiliza√ß√£o
da mem√≥ria RAM e EPROM do microcontrolador e monitorar os estados
das conex√µes, utilizando um mecanismo de Keep-Alive / Heartbeat. Em
algumas situa√ß√µes pode ocorrer que algumas das partes da comunica√ß√£o
fique fora de sincronia, devido a problemas no link, falhas de software
ou hardware. Esse estado √© geralmente chamado conex√£o semi-aberta
(half-open connection). √â importante que o lado da conex√£o que est√°
funcionando corretamente seja notificado ou detecte a falha da outra
ponta, e tente uma reconex√£o ou fecha a conex√£o semi-aberta. Mesmo
existindo mecanismos similares em alguns protocolos como o TCP/IP,
ele pode n√£o ser ideal para alguns tipos de aplica√ß√µes, pois em m√©dia
ele √© executado em um intervalo de duas horas e n√£o permite ajustes
a n√≠vel de aplica√ß√µes, necessitando de ajustes no sistema operacional\cite{key-keepa}.
Por outro lado, outras conex√µes (ex.: USB) n√£o suportaram este mecanismo.
Para contornar esses problemas, o recurso de Keep-Alive / Heartbeat
foi implementado no firmware. Quando √© habilitado o suporte ao protocolo
MQTT, o mecanismo de Keep-Alive do pr√≥prio protocolo s√£o utilizados.

Este mecanismo √© implementado atrav√©s do envio de comando do tipo
PING, em um intervalo ajust√°vel e aguardando seu retorno atrav√©s do
comando do tipo PING\_RESPONSE, podendo ser habilitado e desabilitado
conforme a necessidade. Ao detectar uma falha ou estouro do tempo
determinado (time-out), a aplica√ß√£o ou middleware decide o que fazer
com a conex√£o em estado inv√°lido, se tenta uma reconex√£o ou finaliza
a conex√£o, liberando os recursos alocados.


\subsection{Extensibilidade\label{subsec:FirmwareExtensibilidade}}

O firmware √© projetado como uma biblioteca, permitindo aos desenvolvedores
facilmente customizar e criar seu pr√≥prio firmware atrav√©s da inclus√£o
do c√≥digo de usu√°rio (Sketch, vide figura \ref{fig:ArquiteturaFirmware}).
O mecanismo de conex√µes (Connections Framework) tamb√©m √© flex√≠vel,
permitindo plugar novas conex√µes facilmente, atrav√©s da extens√£o da
classe \emph{DeviceConnection}, ou atrav√©s do mecanismo de ``Custom
Connections'', que permite a cria√ß√£o de novas conex√µes, sobrescrevendo
m√©todos predefinidos usando apenas arquivos de cabe√ßalho (.h). Mais
detalhes ser√£o apresentados a seguir.

A classe Device pode ser estendida para dar suporte a dispositivos
(sensores ou atuadores) mais complexos, que utilizem mais de um pino
ou trabalhem com um protocolo espec√≠fico (ex.: SPI, OneWire). Um exemplo
de especializa√ß√£o desta classe √© realizado pele classe \emph{RFIDSensor},
dispon√≠vel nas bibliotecas do firmware, que permite a integra√ß√£o de
um sensor RFID de proximidade (baseado no chip MFRC522). A inclus√£o
de novos dispositivos, √© realizada estendendo a classe Device e implementando
os m√©todos ``setValue'' e ``hasChanged''. 

Outro m√©todo de inclus√£o de novos dispositivos, mais especificamente
sensores, permite a integra√ß√£o com sensores mais complexos (que utilizem
um protocolo espec√≠fico), de uma forma simplificada e sem a necessidade
de estender a classe Device, facilitando assim a integra√ß√£o e testes.
A listagem \ref{alg:firmware-newsenor} apresenta um exemplo deste
recurso, onde a leitura do sensor √© implementada por um m√©todo definido
pelo usu√°rio no programa principal (Sketch), onde o m√©todo deve retornar
a leitura do sensor. O firmware √© respons√°vel por executar esse m√©todo
e verificar se houve alguma mudan√ßa no valor do sensor, caso exista
alguma altera√ß√£o, as aplica√ß√µes s√£o notificadas.

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
void setup(){
    ODev.addSensor(readRfid); // ID:1
    // ... sensor setup ...
    ODev.begin();
}

unsigned long readRfid(){
  // sensor logic
}
\end{lstlisting}
\inputencoding{utf8}
\caption{Suporte a novos sensores\label{alg:firmware-newsenor}}
\end{algorithm}


\subsubsection{Mecanismo ``Custom Connections''}

Nativamente o \emph{firmware} suporta qualquer conex√£o que estenda
a classe \emph{Stream} (do Arduino). Caso seja necess√°rio a inclus√£o
de outro mecanismo de comunica√ß√£o, onde a biblioteca projetada para
o mesmo n√£o implemente a classe Stream, um ``adaptador'' pode ser
criado para essa conex√£o. Exemplos dessa implementa√ß√£o s√£o encontrados
no pr√≥prio firmware (arquivo: EthernetServerConnection.h) e a estrutura
b√°sica √© apresentada na listagem \ref{alg:firmware-custconn}. A vantagem
√© que n√£o √© necess√°ria a cria√ß√£o de classes (C++), necessitando apenas
de um arquivo de cabe√ßalho (.h). Ao realizar a inclus√£o deste cabe√ßalho
no programa, o firmware automaticamente detecta que deve ser usado
essa conex√£o e realiza as chamadas dos m√©todos implementados. √â importante
que a classe retornada pelo m√©todo ``\_loop()'', seja uma inst√¢ncia
e estenda a classe ``Stream'' para que o mecanismo funcione. 

\begin{algorithm}[H]
\inputencoding{latin9}\begin{lstlisting}[language={C++}]
#define USING_CUSTOM_CONNECTION 1
#define CUSTOM_CONNECTION_CLASS YourClassExtendStream

void custom_connection_begin(){
  
}

CUSTOM_CONNECTION_CLASS custom_connection_loop(DeviceConnection *conn){
  return // return instance of YourClassExtendStream;
}

\end{lstlisting}
\inputencoding{utf8}
\caption{Exemplo do mecanismo ``Custom Connections'' \label{alg:firmware-custconn}}
\end{algorithm}


\section{Fluxo de Mensagens\label{subsec:FluxoMensagens}}

Nesta se√ß√£o abordamos os principais fluxos de execu√ß√£o, encontrados
no firmware, middleware e aplica√ß√µes, auxiliando a entender o processo
interno de execu√ß√£o e quais componentes s√£o utilizados em cada etapa.

\subsection{Envio de Comandos\label{subsec:FluxoEnvioComandos}}

A figura \ref{fig:seq_command_send}, apresenta o fluxo de envio de
comandos entre uma aplica√ß√£o, que se comunica diretamente com os dispositivos
(firmware). A primeira etapa inicia com a abstra√ß√£o do dispositivo
e a execu√ß√£o do seu m√©todo ``on'' ou ``setValue'' (ex.: led.on()).
Esse m√©todo gera um evento que √© capturado pelo framework (fluxo 1),
atrav√©s da classe \emph{DeviceManager}, que cria o comando apropriado,
no caso o \emph{DeviceCommand}, e inicializa com as informa√ß√µes do
ID do dispositivo, tipo (ANALOG ou Digital) e valor e repassa para
o CommandDelivery (fluxo 1.2), que cuida do envio para as conex√µes
de sa√≠da de modo ass√≠ncrono, usando a \emph{SendTask}. As mensagens
s√£o serializadas para o formato do protocolo (\ref{subsec:Protocolo})
do OpenDevice usando o \emph{MessageSerializer}. Cada comando enviado,
recebe um ID (TrackingID), que √© gerenciado pelo CommandDelivery,
e √© usado para fazer o mapeamento dos comandos enviados e comandos
recebidos (fluxo 2 e 3). O ID do comando √© gerado de forma sequencial,
at√© um limite estabelecido pelo protocolo, depois √© reiniciado a contagem.
A SendTask, √© registrada para receber os eventos das conex√µes. Quando
a resposta √© recebida pela conex√£o, o m√©todo ``onMessageReceived''
(fluxo 3) √© executado, e a resposta √© mapeada para o comando enviado.

\begin{figure}[h]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/seq_command_send}
\par\end{centering}
\caption{Envio de Comandos\label{fig:seq_command_send}}
\end{figure}


\subsection{Processamento dos Comandos (Dispositivo)}

A figura \ref{fig:seq_firmware_read}, demonstra o fluxo de execu√ß√£o
do firmware, para realizar a leitura dos comandos das aplica√ß√µes (ou
do middleware), transforma-lo em a√ß√µes reais.

Os comandos recebidos s√£o tratados por uma implementa√ß√£o da classe
\emph{Stream} (fluxo 1), que pode ser uma implementa√ß√£o nativa do
Arduino, como a \emph{Serial} ou \emph{EthernetClient}, ou uma implementa√ß√£o
disponibilizada por uma biblioteca de terceiros, que implementa outra
tecnologia de comunica√ß√£o. Geralmente esses dados s√£o armazenados
em um buffer, de software ou de hardware, e ser√£o lidos no ciclo de
``loop'' do programa principal, atrav√©s da chamada do ``checkDataAvailable''
(fluxo 2), que ao identificar o final da mensagem especificado no
protocolo, faz a desserializa√ß√£o atrav√©s do m√©todo ``parseCommand''
( fluxo 2.3), e repassa para a classe principal da biblioteca do OpenDevice
(fluxo 2.4), que verifica que tipo de comando foi recebido e faz o
tratamento adequado. Caso a mensagem recebida (fluxo 2.4), seja um
\emph{DeviceCommand} (Ex.: Analogic ou Digital), o dispositivo relacionado
√© localizado atrav√©s do ``DeviceID'', e em seguida seu valor √© alterado
(fluxo 3), conforme o valor recebido pelo comando. Em seguida a implementa√ß√£o
do Device determina como ser√° o tratamento para o valor recebido.
Por exemplo, se o dispositivo for um dispositivo do tipo DIGITAL,
a implementa√ß√£o chama o m√©todo ``digitalWrite'' da API do Arduino,
caso seja um Device do tipo ANALOG, a implementa√ß√£o chama o m√©todo
``analogWrite''.

Quando um comando √© recebido com sucesso e o dispositivo relacionado
√© encontrado, uma resposta √© enviada para a aplica√ß√£o (fluxo 4.1.1),
informando o estados da execu√ß√£o. Essa resposta √© encapsulada atrav√©s
da classe \emph{ResponseCommand}, podendo ter v√°rios status, conforme
a tabela \ref{tab:CommandStatusResp}, na se√ß√£o referente ao protocolo
(\ref{subsec:Protocolo}).

\begin{figure}[h]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/seq_firmware_read}
\par\end{centering}
\caption{Processamento dos Comandos\label{fig:seq_firmware_read}}
\end{figure}


\subsection{Recebimento de Comandos}

O diagrama de sequ√™ncia apresentado na figura \ref{fig:seq_send_response},
trata-se da continua√ß√£o do fluxo, quando o dispositivo (firmware)
devolve a resposta com o status da execu√ß√£o do comando para a aplica√ß√£o
ou middleware. O componente que far√° a leitura dos dados brutos, depende
da implementa√ß√£o da conex√£o. No exemplo da figura, foi utilizando
um \emph{StreamReader}, mais especificamente \emph{CommandStreamReader},
que √© a implementa√ß√£o base para lidar com as conex√µes implementados
no m√≥dulo \noun{connection-stream} (USB e Bluetooth por exemplo).
Essa implementa√ß√£o em espec√≠fico, utiliza uma ``thread'' para leitura
dos dados de cada conex√£o, e ao identificar o recebimento do pacote
completo, ele notifica a conex√£o (fluxo 1.3), que por sua vez notifica
os componentes interessados (fluxos 2 e 3).

Quando se trata de uma resposta de um comando, por exemplo DeviceCommand,
a SendTask, criada e gerenciada pelo CommandDelivery, √© notificada
e atualiza o status do comando que foi enviado, com base do ID do
comando (TrackingID) e faz a libera√ß√£o (remove a trava) do comando.

Caso n√£o seja uma resposta de um comando, por exemplo a leitura de
um sensor, o CommandDelivery n√£o √© utilizado . O respons√°vel por tratar
esse comando √© o DeviceManager, como ser√° visto na se√ß√£o seguinte
(\ref{subsec:LeituraSensores}).

\begin{figure}[h]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/seq_send_response}
\par\end{centering}
\caption{Recebimento de Comandos\label{fig:seq_send_response}}
\end{figure}


\subsection{Leitura de Sensores\label{subsec:LeituraSensores}}

O fluxo da leitura de sensores, apresentados nas figuras \ref{fig:seq_firmware_read_poll}
e \ref{fig:seq_firmware_read_interrupt}, trata-se tamb√©m de um fluxo
de recebimento de comandos, √© similar ao da figura \ref{fig:seq_send_response}.
Como abordamos na se√ß√£o \ref{subsec:FirmwareLeituraSensores}, o sistema
de leitura de sensores √© implementado de dois modos: s√≠ncrono (polling)
e ass√≠ncrono (interrup√ß√µes). O modo utilizado depende do suporte que
o \emph{hardware.} Como exemplo, utilizamos um microcontrolador AVR~8Bits~(ex.:
Arduino), executando o firmware, e enviando os dados dos sensores
para a aplica√ß√£o (ou middleware).

\subsubsection{Leitura S√≠ncrona (Polling)}

No modo s√≠ncrono, a leitura dos sensores √© feito no ``loop'' principal,
e √© realizada pela classe \emph{OpenDevice}, atrav√©s do m√©todo ``checkSensorsStatus()''
(fluxo 1). Neste m√©todo todos os sensores ser√£o lidos de forma sequencial,
atrav√©s do m√©todo ``hasChanged()'' da classe Device. Ao executar
esse m√©todo o valor do dispositivo √© atualizado, e caso tenha sofrido
alguma altera√ß√£o (fluxo 1.1.2), um comando (\emph{DeviceCommand})
com o ID do dispositivo e valor lido √© enviado para ao conex√£o (fluxo
1.2), que cuida de serializar e enviar os dados para a aplica√ß√£o.

\begin{figure}[h]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/seq_firmware_read_poll}
\par\end{centering}
\caption{Leitura de Sensores no modo Polling\label{fig:seq_firmware_read_poll}}
\end{figure}


\subsubsection{Leitura Ass√≠ncrona (Interrup√ß√µes)}

O m√©todo de leitura ass√≠ncrona, apresentado na figura \ref{fig:seq_firmware_read_interrupt},
√© realizado atrav√©s de interrup√ß√µes, como mencionamos na se√ß√£o \ref{subsec:FirmwareLeituraSensores}.
Quando habilitado o suporte a interrup√ß√µes, a classe OpenDevice √©
registrada para receber as interrup√ß√µes atrav√©s do m√©todo ``onInterruptReceived()''.
Neste m√©todo o dispositivo correspondente ao pino que sofreu a interrup√ß√£o
√© localizado, e seu valor √© atualizado. Os dispositivos que sofrerem
altera√ß√µes nos seus valores durante a interrup√ß√£o, s√£o marcados para
sincroniza√ß√£o (fluxo 1.2), que ir√° ocorrer na pr√≥xima execu√ß√£o do
‚Äúloop‚Äù principal do programa. Similar √† leitura s√≠ncrona, o m√©todo
``checkSensorsStatus()'' √© chamada no ``loop'', por√©m neste caso
n√£o √© feito nenhuma leitura dos pinos, apenas o envios das informa√ß√µes
para dos dispositivos que sofreram altera√ß√µes para a aplica√ß√£o (fluxo
1.2 e 2.1). A vantagem neste caso √© que enquanto est√£o sendo enviadas
as informa√ß√µes para aplica√ß√£o, caso algum dispositivo tenha seu valor
alterado, a interrup√ß√£o cuida de deslocar o fluxo de execu√ß√£o, salvar
esse valor e retornar para a serializa√ß√£o dos dados. Na implementa√ß√£o
no modo s√≠ncrona (polling), esse valor seria perdido.

\begin{figure}[h]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/seq_firmware_read_interrupt}
\par\end{centering}
\caption{Leitura de Sensores usando Interrup√ß√µes\label{fig:seq_firmware_read_interrupt}}
\end{figure}


\subsection{Envio de Comandos (Aplica√ß√£o - Middleware - Dispositivo)}

A figura \ref{fig:seq_send_ws}, apresenta o fluxo de execu√ß√£o de
um comando enviado por uma aplica√ß√£o cliente (WebApp) para os dispositivos,
atrav√©s do middleware. O framework trabalha com dois conceitos de
conex√µes: (1) conex√µes de entrada, ou seja, os servidores e (2) conex√µes
de sa√≠da, geralmente as conex√µes com os dispositivos f√≠sicos. O componente
representado em ``WSServerConnection'', √© um servidor WebSocket
disponibilizado pelo m√≥dulo \noun{rest-ws-server, }que atua como uma
conex√£o de entrada. A aplica√ß√£o web no exemplo, est√° utilizando a
biblioteca \noun{opendevice-js}, uma das implementa√ß√µes de cliente
usando WebSocket, permitindo a conex√£o de forma simples com o servidor,
e oferecendo a abstra√ß√£o dos dispositivos para a camada Web.

Ao alterar o valor de algum dispositivo na camada Web, que pode ser
atrav√©s dos m√©todos nos objetos JavaScript (fluxo 2), ou atrav√©s de
m√©todos disponibilizados no \noun{opendevice-js}, um comando √© enviado
via WebSocket para o Middleware (fluxo 2.1). A representa√ß√£o da conex√£o
com o cliente ``WSResource'' recebe o comando (fluxo 2.1.1) e notifica
para o DeviceManager (fluxos 2.1.2 e 2.1.2.1), que faz a atualiza√ß√£o
do dispositivo relacionado ao comando recebido, salva no hist√≥rico
de altera√ß√µes, e repassa o comando para os dispositivos f√≠sicos atrav√©s
das conex√µes de sa√≠da. O procedimento de envio, representado na imagem
pelo bloco ``Ref: Send Command'', √© o mesmo procedimento realizado
no fluxo apresentado na se√ß√£o Envio de Comandos (\ref{subsec:FluxoEnvioComandos}).

O recebimento da resposta do dispositivo f√≠sico (fluxo 3), √© redirecionado
para a conex√£o de origem (WSResource). O redirecionamento √© feito
baseado na identifica√ß√£o da conex√£o (UUID), que √© gerado no momento
de sua cria√ß√£o (fluxo 1.1.1), e o mesmo √© associado ao comando quando
ele √© enviado ou recebido, sendo ent√£o poss√≠vel enviar a resposta
para o cliente correto. Deste modo √© poss√≠vel permitir que m√∫ltiplas
aplica√ß√µes acessem o mesmo dispositivo, contornando as limita√ß√µes
do USB e Bluetooth que permitem apenas um cliente, ou mesmo de conex√µes
Ethernet ou Wi-Fi, que dependendo do hardware, podem suportar apenas
um cliente ou um n√∫mero limitado.

\begin{figure}[h]
\begin{centering}
\includegraphics[width=1\linewidth]{Imagens/Cap_4/seq_send_ws}
\par\end{centering}
\caption{Envio de comandos\label{fig:seq_send_ws}}
\end{figure}

\input{Capitulos/4_Secao_Protocolo.tex}


