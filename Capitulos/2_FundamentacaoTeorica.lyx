#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Principal.lyx
\maintain_unincluded_children false
\language brazilian
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Fundamentação Teórica
\end_layout

\begin_layout Section
Internet das Coisas
\end_layout

\begin_layout Standard
O termo Internet das Coisas (em inglês, Internet of Things - IoT), foi usado
 pela primeira vez em 1999 pelo pesquisador britânico Kevin Ashton
\begin_inset CommandInset citation
LatexCommand cite
key "Ashton2009"

\end_inset

.
 O autor descreve a Internet das Coisas como um sistema através do qual
 os objetos do nosso cotidiano possam se conectar à internet usando sensores.
 Ashton aplicou esse termo para explicar o poder da conectividade das tags
 de rádio frequência identificada (RFID), usadas pelas grandes empresas
 para contagem de estoques sem a necessidade da interferência humana.
\end_layout

\begin_layout Standard
Em 
\begin_inset CommandInset citation
LatexCommand cite
key "santos2014"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(2010 apud SANTOS 2013 [3])
\end_layout

\end_inset

, os pesquisadores definem IoT como “uma rede de objetos interconectados,
 os quais poderiam possuir seus próprio endereço de IP, estar incorporados
 a sistemas complexos e usar sensores para monitorar o ambiente, respondendo
 a mudanças de contexto”.
 Tais pesquisadores ainda avaliam a Internet das Coisas em quatro aspectos.
 O primeiro é a possibilidade de seus sistemas conduzirem seus processos
 de forma independente da Internet atual.
 O segundo é que a IoT é construída em conjunto com novos serviços.
 O terceiro é que ela serve como ponte de comunicação não somente entre
 pessoas e objetos, mas também entre objetos e objetos (M2M ou Machine-to-Machin
e), e por último é que as redes podem ser abertas (públicas) ou fechadas
 (privadas ou restritas somente para alguns dispositivos).
\end_layout

\begin_layout Standard
A internet revolucionou a forma como as pessoas se comunicam em escala global,
 o próximo passo é intercomunicar as 
\begin_inset Quotes eld
\end_inset

coisas
\begin_inset Quotes erd
\end_inset

.
 Os recentes avanços na tecnologia de sistemas micro-eletro-mecânicos nas
 comunicações sem fio e na eletrônica digital, possibilitaram a construção
 de microcontroladores e sensores de tamanho e custo reduzidos.
 A proliferação destes dispositivos em uma rede de comunicação cria a chamada
 Internet das Coisas (IoT).
\end_layout

\begin_layout Standard
Na última edição do IoT World Forum, realizada de entre 6 e 8 de dezembro
 de 2015 em Dubai
\begin_inset CommandInset citation
LatexCommand cite
key "url:computerworld:2015,url:webintel:2015,url:cisco:iot:2015"

\end_inset

, foram divulgados alguns dados que demostram o tamanho do crescimento da
 IoT.
 Entre eles:
\end_layout

\begin_layout Itemize
58% das empresas do mercado dizem que IoT é estratégico para seu futuro
 (se tiver, uma referência mais específica); 
\end_layout

\begin_layout Itemize
Atualmente o crescimento de sistemas de IoT tem dobrado ano a ano; 
\end_layout

\begin_layout Standard
Crescimento da IoT entre 2013 e 2015:
\end_layout

\begin_layout Itemize
Sensores colocados no mercado: 10 bilhões em 2013 e 55 bilhões em 2015;
 
\end_layout

\begin_layout Itemize
Conexões de IoT: 11 bilhões em 2013 e 18 bilhões em 2015; 
\end_layout

\begin_layout Itemize
Conexões M2M: 43 bilhões em 2013 e 73 bilhões em 2015; 
\end_layout

\begin_layout Itemize
Empresas participantes em consórcios e associações da IoT: 44 em 2013 e
 354 em 2015;
\end_layout

\begin_layout Standard
Investimentos:
\end_layout

\begin_layout Itemize
Desenvolvedores focados em IoT: 291 mil em 2013 e 813 mil em 2015; 
\end_layout

\begin_layout Itemize
Startups em IoT: 127 em 2013 e 1.502 em 2015;
\end_layout

\begin_layout Itemize
Investimentos de Capital de Risco: US$1,1 bilhão em 2013 e US$ 2 bilhões
 em 2015;
\end_layout

\begin_layout Standard
Oportunidades:
\end_layout

\begin_layout Itemize
Receita gerada por IoT: US$ 548 bilhões em 2013 e US$ 780 bilhões em 2015;
 
\end_layout

\begin_layout Itemize
Receita de serviços de M2M: US$ 79 bilhões em 2013 e US$ 122 bilhões em
 2015;
\end_layout

\begin_layout Itemize
“Coisas” não conectadas em 2013: 99,25% e em 2015 98,85%.
\end_layout

\begin_layout Standard
Previsão para o ano 2020:
\end_layout

\begin_layout Itemize
50 bilhões de “coisas” conectadas; 
\end_layout

\begin_layout Itemize
6 dispositivos por pessoa;
\end_layout

\begin_layout Itemize
US$ 11 trilhões de dólares em novos negócios.
 
\end_layout

\begin_layout Standard
Vários protocolos de aplicação divergentes têm sido propostos para Internet
 das Coisas, incluindo CoAP, REST, XMPP, AMQP, MQTT, DDS e outros.
 Cada protocolo incide sobre um aspecto específico das comunicações da Internet
 das Coisas.
 A falta de um protocolo que possa lidar com as exigências verticais de
 mercado de aplicações da Internet das Coisas, incluindo máquina-a-máquina,
 máquina-servidor, e comunicações de servidor para servidor resultou em
 uma fragmentação do mercado entre muitos protocolos.
 Por sua vez, esta fragmentação é um obstáculo principal no desenvolvimento
 de novos serviços que exigem a integração de múltiplos serviços da Internet
 das Coisas para desbloquear novas capacidades e proporcionar uma integração
 horizontal entre os serviços.
\end_layout

\begin_layout Standard
Diferentes organismos de normalização e grupos estão ativos na criação de
 pilhas de protocolo mais interoperáveis e de normas abertas para a Internet
 das Coisas.
 À medida que avançamos a partir do HTTP, TCP e IP para uma pilha de protocolos
 específicos para Internet das Coisas, eventualmente, nos deparamos com
 uma sopa de acrônimos de protocolos sem fio, como ZigBee, RFID, Bluetooth,
 e BACnet às normas de protocolo de última geração, tais como 802.15.4e, 6LoWPAN,
 RPL, e CoAP, que tentam unificar as redes de sensores sem fio e a Internet
\begin_inset CommandInset citation
LatexCommand cite
key "electronicdesign:2016"

\end_inset

.
 
\end_layout

\begin_layout Standard
Por definição, a Internet das Coisas tem um enorme abrangência, que pode
 ser difícil de atender através de um única solução.
 A IoT pode ser dividida em cinco principais setores (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:iot-report"

\end_inset

), que seriam as principais verticais de adoção da IoT
\begin_inset CommandInset citation
LatexCommand cite
key "Goldman2014"

\end_inset

: dispositivos vestíveis (
\emph on
Wearables
\emph default
), carros conectados, casas conectadas, cidades conectadas e Industriais.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/iot-report.svg
	width 70line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Principais áreas de adoção
\end_layout

\end_inset

 Principais áreas de adoção (traduzido e adaptado de 
\begin_inset CommandInset citation
LatexCommand cite
key "Goldman2014"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:iot-report"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na abertura do evento IoT Week 2013, Ashton afirmou que "A IoT é aqui e
 agora; não é o futuro, mas o presente"
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://kevinjashton.com/2013/06/17/pre-recorded-opening-talk-for-internet-of-thin
gs-week-helsinki- june-17-2013/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Talvez seja interressante flar do :
\end_layout

\begin_layout Plain Layout
2.1 Comparação entre M2M e IoT (Estudo dos protocolos de comunicação MQTT
 e CoAP-para...)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sistemas Embarcados
\end_layout

\begin_layout Standard
Um sistema embarcado é uma combinação de hardware e software, projetados
 para executar uma função específica 
\begin_inset CommandInset citation
LatexCommand cite
key "Noergaar2005"

\end_inset

.
 Como acontece com qualquer sistema eletrônico, este sistema requer uma
 plataforma de hardware construída com um microprocessador ou microcontrolador.
 O hardware do sistema embarcado inclui elementos como interface do usuário,
 interfaces de entrada/saída (I/O), display, memória, etc.
 Geralmente, um sistema embarcado é composto por uma fonte de alimentação,
 processador, memória, temporizadores, portas de comunicação serial e circuitos
 específicos da aplicação do sistema.
\end_layout

\begin_layout Standard
Sistemas embarcados são mais limitados em hardware e software do que um
 computador pessoal (PC).
 Em termos de limitações de hardware, isto pode significar limitações no
 desempenho de processamento, o consumo de energia, memória, e assim por
 diante
\begin_inset CommandInset citation
LatexCommand cite
key "Noergaar2005"

\end_inset

.
\end_layout

\begin_layout Subsection
Tipos de Sistemas Embarcados
\end_layout

\begin_layout Standard
Sistemas embarcados podem ser classificados em diferentes tipos: com base
 no desempenho, requisitos funcionais e de desempenho do microcontrolador.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/embedded-systems-types.svg
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tipos de Sistemas Embarcados 
\begin_inset CommandInset citation
LatexCommand cite
key "url-efxkits"

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:embedded-systems-types"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sistemas embarcados são classificados em quatro categorias com base em seu
 desempenho e requisitos funcionais:
\end_layout

\begin_layout Itemize
Sistemas embarcados autônomos;
\end_layout

\begin_layout Itemize
Sistemas embarcados em tempo real; 
\end_layout

\begin_layout Itemize
Sistemas embarcados em rede; 
\end_layout

\begin_layout Itemize
Sistemas embarcados móveis.
\end_layout

\begin_layout Standard
Sistemas embarcados são classificados em três tipos, com base no desempenho
 do microcontrolador, tal como:
\end_layout

\begin_layout Itemize
Sistemas embarcados de pequena escala; 
\end_layout

\begin_layout Itemize
Sistemas embarcados de média escala; 
\end_layout

\begin_layout Itemize
Sistemas embarcados sofisticados.
\end_layout

\begin_layout Standard
Neste trabalho, abordaremos com mais ênfase os sistemas embarcados de pequena
 escala, compreendendo os microcontroladores, e os de média escala, compreendend
o os mini PCs.
\end_layout

\begin_layout Subsection
Microcontroladores
\end_layout

\begin_layout Standard
Um microcontrolador é um sistema computacional completo, no qual estão incluídos
 uma CPU (Central Processor Unit), memória de dados e programa, um sistema
 de clock, portas de entrada/saída (I/O), além de outros possíveis periféricos,
 tais como, módulos de temporização e conversores A/D entre outros, integrados
 em um mesmo componente
\begin_inset CommandInset citation
LatexCommand cite
key "Chou1992"

\end_inset

.
\end_layout

\begin_layout Standard
Os sistemas micro-controlados estão presentes nas mais diversas áreas, dentre
 as quais estão a automação industrial, automação comercial, automação predial,
 área automobilística, agrícola, produtos manufaturados, eletrodomésticos,
 telecomunicações, etc.
 A Texas Instruments é creditada com a criação do primeiro microcontrolador,
 a série TMS1000.
 Os microcontroladores série TMS1000 tiveram bastante RAM, ROM e I/O e foram
 usados como controladores de forno de micro-ondas, em temporizadores industriai
s, e em calculadoras
\begin_inset CommandInset citation
LatexCommand cite
key "Gadre2000"

\end_inset

.
\end_layout

\begin_layout Standard
Em geral, os microcontroladores são projetados para serem fáceis de utilizar,
 do ponto de vista do projetista de circuitos.
 A Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:microcontroller"

\end_inset

 representa o diagrama de blocos do que um microcontrolador típico, especialment
e, os da série PIC.
 Um microcontrolador pode fazer interface com motores, displays, leitura
 de sensores externos, realizar a comunicação com um PC e mesmo se conectar
 a uma rede de controladores semelhantes, e pode fazer tudo isso sem uma
 quantidade excessiva de componentes.
 Isto leva a um pequeno e compacto sistema que é mais confiável e de baixo
 custo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/microcontrroler_pic.gif
	width 80line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de Blocos - PIC16F887 
\begin_inset CommandInset citation
LatexCommand cite
key "MilanVerle2008"

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:microcontroller"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Em seguida, apresentamos os componentes do microcontrolador.
\end_layout

\begin_layout Itemize

\series bold
CPU:
\series default
 A unidade central de processamento (CPU) é o coração do controlador.
 Ela obtém as instruções armazenadas na memória de programa, decodifica
 essas instruções, e executa.
 A CPU em si é composto de registradores, a unidade lógica aritmética (ALU),
 decodificador de instrução, e circuitos de controle.
\end_layout

\begin_layout Itemize

\series bold
Memória de Programa
\series default
: A memória de programa armazena as instruções que formam o programa.
 Para acomodar programas maiores, a memória de programa pode ser particionada
 como memória de programa interno e externo em alguns controladores.
 A memória de programa é geralmente não volátil e pode ser EPROM, EEPROM,
 Flash, Mask ROM ou OTP (one-time programmable).
\end_layout

\begin_layout Itemize

\series bold
RAM
\series default
: A memória RAM é a memória de dados do controlador, ou seja, ela é usada
 pelo controlador para armazenar dados.
 A CPU usa memória RAM para armazenar variáveis, bem como a pilha.
 A pilha é usada pelo processador para armazenar endereços de retorno a
 partir de onde pode retomar a execução depois de ter completado uma sub-rotina
 ou uma chamada de interrupção.
\end_layout

\begin_layout Itemize

\series bold
Oscilador e Clock
\series default
: O controlador executa o programa a uma determinada taxa.
 Esta velocidade é determinada pela frequência do oscilador.
 O oscilador pode ser um oscilador RC-interno ou um oscilador com um elemento
 de sincronismo externo, tal como um cristal de quartzo.
 Assim que a energia é aplicada ao controlador, o oscilador começa a funcionar.
\end_layout

\begin_layout Itemize

\series bold
Porta Serial
\series default
: Ela é usada para se comunicar com dispositivos externos através de uma
 comunicação serial, onde os dados são enviados ou recebidos em 1 bit de
 cada vez.
 A porta serial pode operar em qualquer velocidade de transferência, porém
 as mais usadas são 9800bps e 115200bps.
 As portas seriais são de dois tipos: síncronas e assíncronas.
 A transferência de dados síncrona precisa de um sinal de relógio (clock),
 para realizar a 
\begin_inset Quotes eld
\end_inset

sincronização
\begin_inset Quotes erd
\end_inset

 do envio dos bits de dados, enquanto a transferência de dados assíncrona
 não precisa do sinal do relógio, e a informação de sincronização está incorpora
do nos dados, utilizando bits de controle no início (START bit) e fim (STOP
 bit) do bloco de dados, que geralmente é de 8-bits.
 O bit START é sempre baixo (0), enquanto o bit STOP é sempre elevado (1).
\end_layout

\begin_layout Itemize

\series bold
Porta I/O Digital
\series default
: O microcontrolador usa os componentes de I/O (Entrada/Saída) digitais
 para a troca de dados digitais com o mundo exterior.
 
\end_layout

\begin_layout Itemize

\series bold
Porta I/O Analógica
\series default
: A entrada analógica é realizada utilizando um conversor analógico-digital
 (ADC).
 ADCs são usados para adquirir dados analógicos de dispositivos, como sensores
 de temperatura e sensores de pressão.
 A saída analógica é realizada utilizando um conversor digital-para-analógico
 (DAC).
 A maioria dos controladores estão equipados com moduladores de largura
 de pulso (PWM) que pode ser usado para obter uma tensão analógica.
\end_layout

\begin_layout Itemize

\series bold
Timer
\series default
: O 
\emph on
timer
\emph default
 é usado pelo controlador para execução de eventos baseados no tempo; por
 exemplo, realizar o controle de velocidade de um motor, o brilho de um
 LED ou gerar um pulso PWM.
 O 
\emph on
timer
\emph default
 também pode ser usado para contar os eventos externos, bem como internos,
 nesse caso, o temporizador é chamado um contador.
 A quantidade de 
\emph on
timers
\emph default
 disponíveis depende do microcontrolador usado.
\end_layout

\begin_layout Itemize

\series bold
Watchdog Timer
\series default
: O 
\emph on
watchdog timer
\emph default
 (WDT) é um temporizador especial, e geralmente é usado para prevenir falhas
 de software.
 Ele funciona da seguinte forma: Uma vez armado, se o programa de usuário
 não reiniciar o contador, notificando que tudo está certo, em um tempo
 máximo predefinido, o contador estoura, ocorrendo o reset do microcontrolador.
 A suposição é que, se o programa do usuário não repõe o WDT, ele falhou
 de alguma maneira e, portanto, em vez de uma falha no sistema ou manter
 um desempenho indesejado, é melhor reiniciar o sistema.
\end_layout

\begin_layout Subsection
Mini PCs
\end_layout

\begin_layout Standard
Primeiramente, precisamos esclarecer que mini PCs não são os desktops comuns,
 que já estão no mercado há alguns anos com placas-mãe pequenas como micro
 ATX e flexATX.
 Estes, muito comuns em caixas de supermercado, por exemplo, são apenas
 versões um pouco reduzidas dos computadores comuns.
\end_layout

\begin_layout Standard
O tipo de máquina que estamos nos referindo são os credit-card sized SBCs
 (single-board computers ou computadores de placa única do tamanho de cartões
 de crédito).
 Além de serem super compactos, estes mini-pcs foram desenhados especificamente
 para serem flexíveis e fáceis de utilizar em projetos diversos por desenvolvedo
res, educadores e hobistas.
 Suas dimensões não ultrapassam os 8 ou 9 centímetros de lado e, como o
 nome já bem diz, possuem todos os seus componentes integrados em uma única
 placa de circuito.
 São também muito eficientes no consumo de energia, dispensando as complicadas
 e volumosas fontes dos PCs comuns e utilizando portas USB ou carregadores
 padrão para sua alimentação.
 Ainda assim, possuem opções de expansão e conectividade bem completas,
 como entrada e saída de áudio, cartão SD, portas USB, saída HDMI e rede
 ethernet.
\end_layout

\begin_layout Standard
Uma categoria especifica de mini PCs, voltada para desenvolvimento de projetos
 embarcados, vem surgindo com o advento da Internet das Coisas.
 Os avanços na tecnologia não permitiram apenas a miniaturização dos computadore
s, permitiram também que seu custo fosse reduzido bastante.
 Uma máquina como o Raspberry Pi custa apenas $35 dólares.
 Outro modelo, o BeagleBone Black custa a partir de $45.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Complementar: Mini-PCs contam com um recurso muito bacana chamado GPIO.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Linguagens de Programação
\end_layout

\begin_layout Standard
As linguagens de programação utilizadas em sistemas profundamente embarcados
 incluem C, C++, e algumas vezes Java.
 É importante notar que o Java é executado, na maioria das vezes, 
\begin_inset Quotes eld
\end_inset

em cima
\begin_inset Quotes erd
\end_inset

 de um sistema operacional, o que limita (mas não impede) sua execução em
 sistemas embarcados como microcontroladores.
 Java é atraente para os dispositivos da Internet das Coisas, porque o número
 de desenvolvedores Java em todo o mundo traz enorme potencial de crescimento
 para a indústria.
 Oracle e ARM estimam que há cerca de 450 mil engenheiros de software embarcado
 em todo o mundo, e cerca de nove milhões de desenvolvedores Java
\begin_inset CommandInset citation
LatexCommand cite
key "java.com:2016"

\end_inset

.
\end_layout

\begin_layout Section
Plataformas de Desenvolvimento
\begin_inset CommandInset label
LatexCommand label
name "sec:Plataformas-de-Desenvolvimento"

\end_inset


\end_layout

\begin_layout Standard
Nesta seção serão apresentadas algumas plataformas de desenvolvimento de
 sistemas embarcados e prototipação, destacando as que tem ganhado mais
 destaque na comunidade.
 A expansão da área de IoT tem estimulado o desenvolvimento de novas ferramentas
, plataformas de prototipação, chips de comunicação, sensores e dispositivos
 diversos, abrindo o leque de opções e reduzindo custos.
\end_layout

\begin_layout Subsection
Arduino
\end_layout

\begin_layout Standard
Arduino
\begin_inset CommandInset citation
LatexCommand cite
key "url:arduino:intro"

\end_inset

 é uma plataforma de código aberto usada para a construção de projetos eletrônic
os.
 Arduino consiste principalmente de uma placa de circuito físico programável
 (muitas vezes referida como um microcontrolador) e um pedaço de software,
 ou IDE (Integrated Development Environment), que é usada para escrever
 e fazer upload de código (firmware) para a placa física
\begin_inset CommandInset citation
LatexCommand cite
key "url:arduino:intro"

\end_inset

.
\end_layout

\begin_layout Standard
O Arduino tem o seu início no 
\emph on
Interaction Design Institute
\emph default
, na cidade de Ivrea, Itália, em 2005.
 O Professor Massimo Banzi estava procurando uma maneira mais fácil e de
 baixo custo para ensinar os estudantes de design a trabalhar com tecnologia.
 Ele discutiu o problema com David Cuartielles, pesquisador visitante da
 Universidade de Malmö, na Suécia, que estava à procura de uma solução semelhant
e, e o Arduino nasceu
\begin_inset CommandInset citation
LatexCommand cite
key "arduino:evans:2013"

\end_inset

.
 O conceito Arduino de hardware aberto foi desenvolvido pela equipe visionária
 de Massimo Banzi, David Cuartielles, Tom Igoe, Gianluca Martino, e David
 Mellis
\begin_inset CommandInset citation
LatexCommand cite
key "arduino:barrett:2012"

\end_inset

.
\end_layout

\begin_layout Standard
Quando a maioria das pessoas pensam em Arduino, eles imaginam a pequena,
 retangular (e provavelmente azul), placa de circuito impresso (PCB), que
 é a parte fisicamente tangível do sistema Arduino.
 Tecnicamente falando, o termo Arduino abrange o hardware, software, equipe
 de desenvolvimento, a filosofia de design, e a comunidade de usuários.
 A Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:arduino"

\end_inset

, apresenta a placa Arduino, bem como, destaca seus principais componentes.
\end_layout

\begin_layout Standard
O Arduino foi originado do projeto Wiring
\begin_inset CommandInset citation
LatexCommand cite
key "Wiring:2016"

\end_inset

, que foi em si um ambiente de desenvolvimento de sistemas embarcados baseados
 em AVR com uma IDE especializada escrita em Java.
 O Wiring, por sua vez, foi originado do Processing
\begin_inset CommandInset citation
LatexCommand cite
key "Processing:2016"

\end_inset

, outra coleção de ferramentas de código aberto para escrever programas
 interativos orientados a gráficos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/arduino.svg
	width 80line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Placa Arduino 
\end_layout

\end_inset

Placa Arduino (traduzido e adaptado de
\begin_inset CommandInset citation
LatexCommand cite
key "url:arduino:bord"

\end_inset

) 
\begin_inset CommandInset label
LatexCommand label
name "fig:arduino"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Características de Hardware
\end_layout

\begin_layout Standard
O Arduino pode ser encontrado em várias versões, a maioria dos placas são
 baseadas no microcontrolador Atmel AVR de 8 bits.
 A primeira placa foi baseada na ATmega8 rodando a uma velocidade de clock
 de 16 MHz com 8 KB de memória flash
\begin_inset CommandInset citation
LatexCommand cite
key "arduino:evans:2013"

\end_inset

.
 Uma das placas mais populares é o Arduino Uno
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Arduino UNO (nos Estados Unidos) e Genuino UNO (fora dos Estados Unidos)
\end_layout

\end_inset

, que utilize o ATmega328p, com memória flash de 32KB e 2 KB de memória
 RAM.
 Nos projetos mais exigentes, que requerem mais I/O e memória, há o Arduino
 Mega 2560 com 256 KB de memória ou o Arduino Due
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://www.arduino.cc/en/Main/ArduinoBoardDue
\end_layout

\end_inset

, baseado no Atmel SAM3X8E ARM Cortex-M3, com 512KB de memória flash e 96
 KB de memória RAM.
\end_layout

\begin_layout Standard
As placas mais populares, em específico o Uno, têm 14 pinos digitais, cada
 um dos quais podem ser definidos como entrada (input) ou saída (output),
 e seis entradas analógicas.
 Além disso, seis dos pinos digitais podem ser programados para proporcionar
 uma saída analógica PWM (Pulse Width Modulation).
 Uma variedade de protocolos de comunicação estão disponíveis, incluindo
 Serial, SPI (Serial Peripheral Interface), e I2C (Inter-integrated Circuit
 Protocol).
 Na placa também é disponibilizada uma entrada ICSP, que permite a programação
 do microcontrolador (que é também realizada pela porta USB) e um botão
 de reset.
\end_layout

\begin_layout Standard
Placas especializadas chamadas 
\emph on
Shields
\emph default
, são usadas para expandir as funcionalidade do Arduino.
 Estas podem ser empilhadas uma em cima da outra para adicionar ainda mais
 funcionalidade, sendo esta, uma das principais facilidades e fator de sucesso
 da plataforma Arduino.
\end_layout

\begin_layout Subsubsection
Características de Software
\end_layout

\begin_layout Standard
Embora, muitas vezes o Arduino seja apresentado como uma linguagem, na perspecti
va de software, ele é na verdade um conjunto de bibliotecas e APIs construídas
 em C/C++, que são baseadas nas APIs do projeto Wiring.
\end_layout

\begin_layout Standard
A programação do Arduino é realizada por uma IDE (Integrated Development
 Environment), escrita em Java e de código aberto
\begin_inset CommandInset citation
LatexCommand cite
key "arduino:source"

\end_inset

, que fornece tudo que é necessário para a programação do Arduino, incluindo
 uma série de programas de exemplo (sketches) que demonstram como conectá-lo
 e se comunicar com alguns dispositivos comuns, como LEDs, LCDs, e alguns
 sensores.
 
\end_layout

\begin_layout Standard
A IDE do Arduino usa uma versão simplificada do C++
\begin_inset CommandInset citation
LatexCommand cite
key "arduino:ref"

\end_inset

, tornando mais fácil aprender a programar e realizar interações com o hardware.
 A estrutura básica de um programa para o Arduino é apresentado na figura
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:arduino-1"

\end_inset

.
 Programas escritos usando a IDE do Arduino são chamados de sketches.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/arduinoide_sketch.png
	width 60line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
IDE do Arduino 
\begin_inset CommandInset label
LatexCommand label
name "fig:arduino-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Raspberry Pi
\begin_inset CommandInset label
LatexCommand label
name "sub:Raspberry-Pi"

\end_inset


\end_layout

\begin_layout Standard
O Raspberry Pi
\begin_inset CommandInset citation
LatexCommand cite
key "url:raspberry"

\end_inset

 é um mini PC de baixo custo, do tamanho de um cartão de crédito, que possui
 recursos consideráveis de processamento e memória.
 Ele foi desenvolvido no Reino Unido, com intuito de fomentar a educação
 para adultos e crianças e logo se destacou na comunidade de desenvolvedores
 antes mesmo do seu lançamento oficial em junho de 2012.
\end_layout

\begin_layout Standard
O equipamento usa como seu Sistema Operacional (S.O), a distribuição Raspbian
 Wheezy, que é baseada no Linux Debian.
 Porém, existem inúmeros Sistemas Operacionais compatíveis
\begin_inset CommandInset citation
LatexCommand cite
key "raspberry:compatible"

\end_inset

, incluindo o Windows 10 IoT Core
\begin_inset CommandInset citation
LatexCommand cite
key "raspberry:compatible1"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Falar em relação a aplicação do Arduino e Raspberry.
\end_layout

\begin_layout Plain Layout
http://cybergibbons.com/uncategorized/arduino-misconceptions-4-the-arduino-is-obs
olete-now-the-raspberry-pi-exists/
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Características de Hardware
\end_layout

\begin_layout Standard
Existem diferentes modelos, que contemplam diferentes características técnicas.
 O Raspberry Pi 2 Model B (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:raspberry"

\end_inset

)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
ref:https://www.raspberrypi.org/products/model-b-plus/
\end_layout

\end_inset

, possui um processador com arquitetura ARM, 900MHz de velocidade (permitindo
 overclock) e 1GB de memória RAM.
 O processador é o BCM 2835, o mesmo usado no iPhone 3g e Kindle 2.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/Raspberry_Pi_B.jpg
	width 80line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Raspberry Pi 2 - Model B 
\begin_inset CommandInset citation
LatexCommand cite
key "img:raspberry"

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:raspberry"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Especificações:
\end_layout

\begin_layout Itemize
SoC: Broadcom BCM2836 (CPU, GPU, DSP, SDRAM);
\end_layout

\begin_layout Itemize
Processador: 900 MHz quad-core ARM Cortex A7 (ARMv7)
\end_layout

\begin_layout Itemize
GPU: VideoCore IV @ 250 MHz / OpenGL ES 2.0 (24 GFLOFS);
\end_layout

\begin_layout Itemize
Memória: 1GB MB (compartilhada com a GPU);
\end_layout

\begin_layout Itemize
Saídas de Vídeo: 
\end_layout

\begin_deeper
\begin_layout Itemize
Vídeo Composto (PAL e NTSC) através de conector P2 com saída de áudio integrada;
\end_layout

\begin_layout Itemize
HDMI (ver 1.3 e 1.4);
\end_layout

\begin_layout Itemize
Interface MIPI para ligar diretamente a painéis LCD.
\end_layout

\end_deeper
\begin_layout Itemize
Saídas de Áudio: Saída de áudio analógica através de conector P2 compartilhada
 com o vídeo composto / HDMI;
\end_layout

\begin_layout Itemize
Interfaces:
\end_layout

\begin_deeper
\begin_layout Itemize
4 x portas USB 2.0;
\end_layout

\begin_layout Itemize
1 x MicroUSB (Alimentação);
\end_layout

\begin_layout Itemize
1 x Entrada MicroSD;
\end_layout

\begin_layout Itemize
1 x Ethernet (10/100Mbps);
\end_layout

\begin_layout Itemize
1 x GPIO (40 pinos) (General Purpose Input/Output).
\end_layout

\end_deeper
\begin_layout Subsubsection
Características de Software
\end_layout

\begin_layout Standard
Devido ao Raspberry Pi utilizar um S.O baseado em Linux e arquitetura ARM,
 inúmeras linguagens de programação são suportadas
\begin_inset CommandInset citation
LatexCommand cite
key "raspberry:langs"

\end_inset

, por exemplo, Java, JavaScript, PHP, Python, Ruby, etc.
 Bem como, é possível executar servidores como Apache, Nginx e MySQL.
\end_layout

\begin_layout Standard
A distribuição oficial, Raspbian
\begin_inset CommandInset citation
LatexCommand cite
key "raspberry:os"

\end_inset

, vem com suporte nativo a Python e Java.
 A versão do Java instalada é a 'jdk-8-oracle-arm-vfp-hflt', fornecida pela
 Oracle.
 É possível, contruir aplicações gráficas utilizando 
\emph on
JavaFX
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "raspberry:javafx"

\end_inset

, tornando o Raspberry Pi, um potencial equipamento para criação de inúmeras
 aplicações embarcadas.
\end_layout

\begin_layout Standard
Para controlar os pinos de GPIO em aplicações Java, existem várias formas.
 Infelizmente a versão instalada não possui o suporte nativo a este recurso
 (algo contraditório).
 Uma recente especificação, denomina 
\emph on
Device I/O
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "device-io:wiki"

\end_inset

, foi projetada para acessar os periféricos dos sistemas embarcados, permitindo
 acesso a recursos como GPIO, I2C, SPI, UART, PWM, etc.
\end_layout

\begin_layout Standard
Para utilizar a API 
\emph on
Device I/O
\emph default
, é necessário instalar a versão 
\emph on
Java ME Embedded
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "device-io:wiki"

\end_inset

, que conta com todos componentes necessários.
 Porém, é possível utilizar API 
\emph on
Device I/O
\emph default
 com a versão do Java instalada por padrão no Raspberry Pi, necessitando,
 neste caso, realizar a compilação da mesma.
\end_layout

\begin_layout Standard
Outra alternativa, é utilizar a biblioteca Pi4J
\begin_inset CommandInset citation
LatexCommand cite
key "raspberry:pi4j"

\end_inset

, que permite realizar o acesso aos periféricos, utilizando uma API Java
 totalmente orientada a objetos.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Já vem com python-rpi.gpio
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
BeagleBone
\end_layout

\begin_layout Standard
A BeagleBone
\begin_inset CommandInset citation
LatexCommand cite
key "beagleboard"

\end_inset

 é outra plataforma na categoria de mini PC, que se propõe a ser um computador
 de baixo custo, projetado para fins educacionais.
 Ela foi projetado pela Texas Instruments, e é totalmente open source, tanto
 em hardware quanto em software.
\end_layout

\begin_layout Standard
O equipamento usa como seu Sistema Operacional (S.O), a distribuição Angstrom
 Linux, porém oferece suporte a outras versões do Linux, incluindo, Debian,
 Ubuntu e Android.
\end_layout

\begin_layout Subsubsection
Características de Hardware
\end_layout

\begin_layout Standard
Existem diferentes modelos, que contemplam diferentes características técnicas.
 A BeagleBone Black (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:beaglebone"

\end_inset

), possui um processador AM3358BZCZ100, arquitetura ARM, 1Ghz de velocidade
 e 512MB de memória RAM.
 Outros modelos podem chegar até 2GB de RAM.
\end_layout

\begin_layout Standard
Um dos diferencias em relação ao Raspberry Pi, é que ela possui uma memória
 flash (eMMC) embutida de 4GB, onde é armazenado o Sistema Operacional,
 o que permite um tempo carregamento do S.O menor (10s), e maior confiabilidade
 do que o cartão MicroSD, utilizado no Raspberry Pi.
\end_layout

\begin_layout Standard
Ao plugar a placa na porta USB do computador, ela é reconhecida como um
 driver virtual de rede e pode ser acessada através do IP fixo
\emph on
 'http://192.168.7.2
\emph default
'.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/beaglebone.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
BeagleBone Black 
\begin_inset CommandInset citation
LatexCommand cite
key "img:BeagleBone"

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:beaglebone"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Especificações:
\end_layout

\begin_layout Itemize
Processador: TI Sitara™ AM3358 ARM® Cortex™-A8
\end_layout

\begin_layout Itemize
GPU: Suporte a aceleração gráfica 3D;
\end_layout

\begin_layout Itemize
Memória: 512MB DDR3;
\end_layout

\begin_layout Itemize
Armazenamento: 4GB 8-bit eMMC Onboard Flash;
\end_layout

\begin_layout Itemize
Saídas de Vídeo: Micro HDMI;
\end_layout

\begin_layout Itemize
Saídas de Áudio: Micro HDMI;
\end_layout

\begin_layout Itemize
Interfaces:
\end_layout

\begin_deeper
\begin_layout Itemize
1 x portas USB 2.0;
\end_layout

\begin_layout Itemize
1 x MicroUSB (Alimentação e Comunicação);
\end_layout

\begin_layout Itemize
1 x Entrada MicroSD;
\end_layout

\begin_layout Itemize
1 x Ethernet;
\end_layout

\begin_layout Itemize
2 x GPIO (46 pinos) (General Purpose Input/Output).
\end_layout

\end_deeper
\begin_layout Subsubsection
Características de Software
\end_layout

\begin_layout Standard
Devido ao S.O ser baseado em Linux, as principais linguagens de programação
 são suportadas.
 A distribuição oficial, Angstrom, vem como uma IDE Web (baseada na Cloud9
 IDE
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://c9.io/
\end_layout

\end_inset

 e Node.JS), que permite executar programas em JavaScript utilizando Node.js
 e a biblioteca BoneScript.
 A biblioteca BoneScript, permite o acesso aos periféricos e pinos de GPIO
 da placa, possui uma sintaxe simples, com algumas funções similares ao
 Arduino
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ref: http://beagleboard.org/Support/bone101
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
O desenvolvimento de aplicações usando Java é suportado, porém, é necessário
 instalar o Java JDK 1.8 SE para plataforma ARM.
 Infelizmente, não está disponível até o momento, a versão 
\emph on
Java ME Embedded 
\emph default
para a BeagleBone
\emph on
, 
\emph default
que oferece suporte a API 
\emph on
Device I/O.

\emph default
 A alterativa, neste caso, é compilar a biblioteca.
 Apesar do site do projeto 
\emph on
Device I/O,
\emph default
 não mencionar a compatibilidade com a esta placa, nos testes efetuados,
 a compilação foi realizada com sucesso e o acesso aos pinos GPIO pode ser
 realizado através do Java
\emph on
.
\end_layout

\begin_layout Standard
Outra alternativa, é utilizar a biblioteca 
\begin_inset Quotes eld
\end_inset

libbulldog
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "beagleboard:libbulldog"

\end_inset

, que permite realizar o acesso aos periféricos, utilizando uma API Java
 totalmente orientada a objetos.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Parece que tem: C++, Perl, Python
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Parece que não suporta JavaFX nativamente:
\end_layout

\begin_layout Plain Layout
https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/javafx.htm
\end_layout

\begin_layout Plain Layout
--
\end_layout

\begin_layout Plain Layout
Do be aware with OpenJFX that JavaFX programs on the BBB will only run in
 X11 with DirectFB being specified as the renderer.
 DirectFB on the BBB with the current revision of OpenJFX that I was using
 had the bizarre GTK requirement, which prevents the framebuffer (no X11)
 from being used.
 Also a custom version of DirectFB must be built and installed.
 There is an ancient version of DirectFB in the Debian/Ubuntu repository
 but it doesn't work with OpenJFX or JavaFX.
\end_layout

\begin_layout Plain Layout
--
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ESP8266
\end_layout

\begin_layout Standard
O ESP8266
\begin_inset CommandInset citation
LatexCommand cite
key "url:esp8266:espressif"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:datasheet"

\end_inset

 é um SoC (System on a Chip), altamente integrado, projetado para as necessidade
s de um mundo cada vez mais conectado.
 Ele oferece uma solução completa e independente de rede Wi-Fi, permitindo
 rodar aplicações embarcadas ou fornecer as funções de rede Wi-Fi para outros
 microcontroladores, através de uma comunicação serial UART.
 O ESP8266 tem poderosas capacidades de processamento e armazenamento que
 permitem que ele seja usado com sensores e outros dispositivos através
 de suas interfaces de GPIO (General Purpose Input/Output).
 Seu alto grau de integração 
\begin_inset Quotes eld
\end_inset


\emph on
on-chip
\emph default

\begin_inset Quotes erd
\end_inset

, permite a simplificação dos projetos de circuitos.
 Toda a solução, incluindo o módulo, está concebido para ocupar uma área
 mínima de PCB (Printed Circuit Board).
 Um dos principais atrativos e fatores de sucesso, é seu baixíssimo custo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://www.sparkfun.com/products/13678
\end_layout

\end_inset

 e a facilidade com que o mesmo pode ser integrado a demais soluções, tornando-s
e uma das plataformas mais populares de desenvolvimento nos últimos anos
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ref:http://learn.acrobotic.com/tutorials/post/esp8266-getting-started
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Características de Hardware
\end_layout

\begin_layout Standard
O ESP8266 (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esp8266"

\end_inset

b) foi desenvolvido pela 
\emph on
Espressif Systems
\emph default
, como uma interface Serial (UART) para Wi-Fi, usando o microcontrolador
 
\emph on
Tensilica Xtensa LX3
\emph default
 de 32-bits, com clock de 80MHz, 32KB RAM (instrução) e 96KB RAM (dados).
 O núcleo da CPU é baseado no Xtensa
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:cadence"

\end_inset

, da Cadence.
\end_layout

\begin_layout Standard
Os módulos ESP8266 são fornecidos numa ampla variedade de modelos, com diferença
s perceptíveis principalmente no que tange à quantidade de pinos I/O disponíveis
 para acesso externo, e no tamanho do módulo.
 Até o presente momento, "oficialmente" existem módulos numerados de ESP-01
 até ESP-12
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:modules"

\end_inset

.
 A Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:esp8266"

\end_inset

a, apresenta o módulo ESP-01.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/esp8266.jpg
	width 80line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Placa ESP8266
\end_layout

\end_inset

Módulo ESP-01 (a), Chip ESP8266 (b), adaptado de 
\begin_inset CommandInset citation
LatexCommand cite
key "url:esp8266:espressif"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:esp8266"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Algumas características do módulo Wireless ESP8266:
\end_layout

\begin_layout Itemize
Conexão à redes padrão 802.11 B/G/N;
\end_layout

\begin_layout Itemize
CPU que opera em 80MHz, com possibilidade de operar em 160MHz;
\end_layout

\begin_layout Itemize
Pilha TCP/IP integrada;
\end_layout

\begin_layout Itemize
Tensão de operação : 3.3 V;
\end_layout

\begin_layout Itemize
Tem conectores GPIO, barramentos I2C, SPI, UART, entrada ADC, saída PWM
 e sensor interno de temperatura;
\end_layout

\begin_layout Itemize
Suporte a memória Flash Externa - 512 KB até 16MB;
\end_layout

\begin_layout Itemize
Modos de operação : Cliente, Access Point, Cliente+Access Point;
\end_layout

\begin_layout Itemize
Modos de segurança Wireless : OPEN/WEP/WPA_PSK/WPA2_PSK/WPA_WPA2_PSK;
\end_layout

\begin_layout Itemize
Suporta comunicação TCP e UDP, com até 5 conexões simultâneas.
\end_layout

\begin_layout Subsubsection
Características de Software
\end_layout

\begin_layout Standard
A Espressif disponibiliza um SDK completo para trabalhar com o ESP8266
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:sdk"

\end_inset

.
 No SDK são disponibilizados recursos para suporte à SSL, JSON, e a biblioteca
 lwIP
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://savannah.nongnu.org/projects/lwip/
\end_layout

\end_inset

, tornando esta uma solução bastante completa para criação de projetos para
 a Internet das Coisas.
 A empresa possui um repositório no GitHub
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:source"

\end_inset

, onde disponibiliza exemplos de código para firmwares com RTOS e comandos
 AT.
 
\end_layout

\begin_layout Standard
Alguns dos módulos vêm pré-carregados com um firmware que os transformam
 em "Pontes Serial-WiFi", permitindo serem configurados e controlados por
 outros microcontroladores (ex.: Arduino).
 Para realizar essa ponte, a interface serial dos módulos obedece a uma
 tabela de comandos, que seguem o padrão AT, que podem variar de acordo
 com a versão do firmware.
 
\end_layout

\begin_layout Standard
Um dos firmwares mais populares é o NodeMCU
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:nodemcu"

\end_inset

, que permite programar o módulo usando a linguagem de programação LUA,
 tornando prático, por exemplo, a criação de um servidor Web com acionamento
 de GPIOs.
 Existe também a possibilidade de programar o ESP8266 usando JavaScript,
 através do firmware Espruino
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:espruino"

\end_inset

, porém ainda em versão Beta.
\end_layout

\begin_layout Standard
Outra opção disponível, é programar o ESP8266 utilizando as APIs do Arduino.
 A IDE do Arduino oferece suporte para o ESP8266, permitido utilizá-lo como
 se fosse um Arduino.
 O núcleo ESP8266 para Arduino
\begin_inset CommandInset citation
LatexCommand cite
key "esp8266:arduino"

\end_inset

 vem com bibliotecas para se comunicar através do Wi-Fi, usando servidores
 TCP e UDP, configurar servidores HTTP, mDNS, e fazer atualizações remotas.
 Permite também utilizar o sistema de arquivos em memória flash ou cartões
 SD e realizar comunicação usando protocolos UART, SPI e I2C.
\end_layout

\begin_layout Section
Rede de Sensores Sem Fio (RSSF)
\end_layout

\begin_layout Standard
A combinação de sensoriamento, processamento e comunicação de interface,
 oferta milhares de aplicações potenciais que é o conceito principal de
 rede de sensores sem fio
\begin_inset CommandInset citation
LatexCommand cite
key "hill2003"

\end_inset

.
 Os nós de sensores sem fio são unidades auto-suficientes que consistem
 em uma fonte de energia, capacidades de comunicação, poder de computação
 e um atuador ou sensor.
 Eles podem se comunicar entre si, coletar dados do ambiente ao redor ou
 se conectar a uma estação base externa ou centro de controle remoto
\begin_inset CommandInset citation
LatexCommand cite
key "olafsen2007"

\end_inset

.
 
\end_layout

\begin_layout Standard
Os recentes avanços tecnológicos em circuitos integrados de baixa potência
 e comunicações sem fio, permitiram a criação de dispositivos cada vez menores,
 com baixo consumo de energia e com baixo custo, tonando-se soluções eficientes
 para uso em aplicações de sensoriamento remoto.
 A combinação desses fatores melhorou a viabilidade de utilizar uma rede
 de sensores composta por um grande número de sensores inteligentes, permitindo
 a coleta, tratamento, análise e disseminação de informações valiosas
\begin_inset CommandInset citation
LatexCommand cite
key "akyildiz2002"

\end_inset

.
\end_layout

\begin_layout Standard
RSSFs em geral caracterizam-se por possuir uma alta densidade de nós.
 Vários sensores monitoram o mesmo fenômeno, gerando dados redundantes e,
 muitas vezes, fornecendo à aplicação um nível de qualidade maior do que
 o necessário.
 Como a maior fonte de consumo de energia nos sensores é a transmissão de
 dados, grande parte dos esforços de pesquisa em RSSFs visa propor soluções
 para obter e rotear os dados de forma eficiente em energia, a fim de estender
 o tempo de vida global da rede.
 Por um lado, há propostas cujo enfoque é minimizar o número de transmissões
 e/ou o tamanho das mensagens, realizando o roteamento eficiente em energia
\begin_inset CommandInset citation
LatexCommand cite
key "heinzelman2000,intanagonwiwat2000"

\end_inset

.
 Por outro lado, pesquisas recentes
\begin_inset CommandInset citation
LatexCommand cite
key "perillo2003:1,perillo2003:2"

\end_inset

, mostram que, em vez de fornecer uma redundância de dados desnecessária
 para a aplicação, a alta densidade de nós pode ser aproveitada para obter
 significativa economia de energia.
 Vários métodos podem ser empregados a fim de se obter essa economia.
 
\end_layout

\begin_layout Standard
A seguir estão algumas propriedades de redes de sensores sem fio:
\end_layout

\begin_layout Itemize

\series bold
Auto-organização:
\series default
 Os nós de sensores podem criar automaticamente a rede e a posição dos nós
 não precisam ser pré-determinada.
 Uma rede de sensores auto-organizáveis não tem nenhuma necessidade de se
 ligar a uma rede estabelecida.
\end_layout

\begin_layout Itemize

\series bold
Comunicação de curto alcance e encaminhamento multi-salto:
\series default
 Comunicação multi-salto em redes de sensores sem fio é esperada para consumir
 menos energia do que a comunicação tradicional de salto único.
 Como sabemos, a potência de transmissão requerida aumenta com a distância
 entre o transmissor e o receptor.
 Consequentemente, muitos pequenos saltos requerem menos energia do que
 um longo salto.
\end_layout

\begin_layout Itemize

\series bold
Cooperação entre nós:
\series default
 Por causa dos recursos limitados dos nós, papéis diferentes são atribuídos
 para nós na rede para alcançar uma rede de baixa potência.
\end_layout

\begin_layout Itemize

\series bold
Topologia Dinâmica:
\series default
 Na rede de sensores sem fio, nós podem falhar e ficar 
\emph on
off-line
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
fora de operação
\end_layout

\end_inset


\emph default
 ou novos nós podem ser adicionados na rede.
 Assim, a topologia da rede opera de forma dinâmica.
\end_layout

\begin_layout Itemize

\series bold
Recursos energéticos limitados, poder computacional e memória:
\series default
 Uma vez que uma rede de sensores sem fio é composta por pequenos dispositivos,
 a rede sofre com limitações de recursos, por exemplo energia, poder computacion
al e memória.
\end_layout

\begin_layout Standard
É geralmente reconhecido que os sensores e redes de sensores serão uma parte
 significativa da IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "Luckenbach2005"

\end_inset

.
 Os sensores podem monitorar o mundo físico por detectar e medir diferentes
 tipos de informações ambientais.
 Ao alimentar aplicações adequadas com esse tipo de informação através de
 vários tipos de objetos do mundo físico, a Internet passaria de "computadores
 interligados" para "as coisas interligadas." Redes inteligentes sensíveis
 ao contexto estão se aproximando rapidamente da posição de sistemas de
 rede integrados, onde o desenvolvimento de minúsculos sensores e atuadores
 pode perfeitamente realizar tais redes em grandes ambientes de fábrica,
 redes para automóveis, residências, escritórios inteligentes e serviços
 de apoio social, incluindo os alertas sísmicos, monitoramento de pacientes
 e sensíveis ao contexto em situações de emergência 
\begin_inset CommandInset citation
LatexCommand cite
key "Luckenbach2005"

\end_inset

.
\end_layout

\begin_layout Section
RFID
\end_layout

\begin_layout Standard
O RFID - 
\emph on
Radio Frequency Identification
\emph default
, ou, em tradução livre, Identificação por Radiofrequência, não é uma tecnologia
 nova, ela teve seu início com o físico escocês Sir Robert Alexander Watson-Watt
 em meados de 1937
\begin_inset CommandInset citation
LatexCommand cite
key "nemoto2012"

\end_inset

.
 Esta tecnologia foi primeiramente usada em sistemas de radares na Segunda
 Guerra Mundial para avisar com antecedência a presença dos aviões aliados
 ou inimigos e que permaneceu restrito somente para uso militar até os anos
 70.
 C.M Roberts, em 
\begin_inset CommandInset citation
LatexCommand cite
key "Roberts2006"

\end_inset

, descreve essa tecnologia como um 
\begin_inset Quotes eld
\end_inset

sistema de transação e identificação de dados por proximidade eletromagnética
\begin_inset Quotes erd
\end_inset

.
 O autor também afirma que o RFID é um melhoria sobre os códigos de barras
 em termos de comunicação por proximidade não ótica.
\end_layout

\begin_layout Standard
Um sistema RFID consiste em leitores (também chamados de interrogadores)
 e etiquetas (ou 
\emph on
transponders
\emph default
).
 Um sistema típico, tem alguns leitores, estacionários ou móveis e muitas
 etiquetas que estão ligadas a objetos, tais como livros, caixas de papelão,
 garrafas, etc
\begin_inset CommandInset citation
LatexCommand cite
key "Chawla2007"

\end_inset

.
 Um leitor se comunica com as etiquetas sem utilizar fios, dentro do seu
 campo de atuação, e coleta informações sobre os objetos aos quais as etiquetas
 estão associadas.
 Dependendo do seu princípio de funcionamento, as etiquetas são classificados
 em três categorias: passivas, semi-passiva e ativa.
\end_layout

\begin_layout Standard
A etiqueta passiva é a menos complexa e, portanto, a mais barata.
 Não tem nenhuma fonte de alimentação interna, e usa o campo eletromagnético
 transmitido por um leitor para alimentar seu circuito interno.
 Ela não se baseia em um transmissor, mas em "retrodifusão" para transmitir
 dados de volta para o leitor.
 A etiqueta semi-passiva tem fonte de energia própria, mas nenhum transmissor,
 usando o mecanismo de "retrodifusão.
 Uma etiqueta ativa, tem tanto fonte de alimentação interna quando transmissor
\begin_inset CommandInset citation
LatexCommand cite
key "Chawla2007"

\end_inset

.
\end_layout

\begin_layout Standard
A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rfid"

\end_inset

 ilustra o funcionamento do sistema RFID passivo que consiste de uma etiqueta
 RFID e uma estação de base chamado "leitor RFID".
 Uma etiqueta passiva consiste em uma antena e um circuito integrado de
 aplicação específica (ASIC), ambos com impedâncias complexas.
 O chip obtém energia a partir do sinal de RF transmitido pelo leitor RFID.
 A etiqueta envia dados de volta ao mudar a sua impedância de entrada entre
 dois estados e modulando assim o sinal por "retrodifusão".
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/rfid.png
	width 50line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visão geral do RFID passivo 
\begin_inset CommandInset citation
LatexCommand cite
key "Chawla2007"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:rfid"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Atualmente, o RFID tem uma gama enorme de aplicabilidade, que vão desde
 os conhecidos cartões de acesso residenciais por proximidade até ao rastreament
o em cadeias de produção, controle estacionamento de veículos, gerenciamento
 de estoque, rastreamento de livros, prevenção de roubos, etc
\begin_inset CommandInset citation
LatexCommand cite
key "Roberts2006"

\end_inset

.
\end_layout

\begin_layout Standard
Esta tecnologia tem se difundido rapidamente pelo mundo, por sua facilidade
 de uso e também pelo fato de dispensar a intervenção humana
\begin_inset CommandInset citation
LatexCommand cite
key "zhu2012review"

\end_inset

.
 no mundo dos negócios o RFID tem recebido grande expectativas com previsão
 de crescimento de US$ 4,96 bilhões em 2007 e US$ 26,88 bilhões em 2017
\begin_inset CommandInset citation
LatexCommand cite
key "RFIDForecasts2007"

\end_inset

.
\end_layout

\begin_layout Standard
O RFID possibilitou a inserção de inteligência nos objetos, trazendo aos
 mesmos a capacidade de comunicarem-se de forma automática
\begin_inset CommandInset citation
LatexCommand cite
key "Khoo2010"

\end_inset

.
 Em 
\begin_inset CommandInset citation
LatexCommand cite
key "Khoo2010"

\end_inset

, o autor afirma que o RFID representa uma tecnologia que possibilitou a
 convergência entre computação, comunicação e interação através de redes
 sem fio, sensores e a grande rede de computadores.
 Em complemento o autor afirma que esta tecnologia tem o potencial que permite
 a máquina identificar objetos, compreender seus estados e tomar medidas,
 se necessário.
 Ou seja, possibilitou aos objetos do nosso cotidiano pensar e interagir.
 Todo esse desenvolvimento contribuiu com a criação da Internet das Coisas
 (IoT), que permite a interação inteligente entre objetos ao redor do mundo.
 As soluções categorizadas de acordo com o domínio de redes de sensores
 e a tecnologia RFID têm abordado de forma eficiente problemas relacionados
 a interoperabilidade, escalabilidade, infraestrutura distribuída, interação
 espontânea
\begin_inset CommandInset citation
LatexCommand cite
key "Luckenbach2005"

\end_inset

.
 
\end_layout

\begin_layout Section
Tecnologias de Comunicação
\end_layout

\begin_layout Standard
A Internet das Coisas necessita de tecnologias de comunicação na camada
 física e do middleware para fornecer o controle dos dispositivos para a
 camada das aplicações.
 Tipicamente, os meios físicos de comunicação entre os dispositivos são
 baseados em três grupos diferentes: cabeamento estruturado, a fiação existente,
 e sem fio
\begin_inset CommandInset citation
LatexCommand cite
key "ngo2007"

\end_inset

.
\end_layout

\begin_layout Standard
Na maioria dos casos, os dispositivos usam a comunicação sem fio porque
 os padrões de tecnologia sem fio estão em toda parte.
 A ampla disseminação de redes sem fio em nossa vida diária está habilitado
 para os padrões de comunicação, como Bluetooth, Zigbee, RFID, Wi-Fi e redes
 móveis (3G/4G).
 Prevê-se uma combinação destas normas e tecnologias, afim de construir
 ambientes inteligentes.
 Efetivamente, todas as tecnologias sem fio que podem apoiar de alguma forma
 a transferência de dados remotos, detecção e controle, são candidatas para
 inclusão no ambiente de IoT.
\end_layout

\begin_layout Subsection
Tecnologias não IP
\end_layout

\begin_layout Subsubsection
ZigBee
\end_layout

\begin_layout Standard
ZigBee é uma tecnologia de rede sem fio desenvolvida pela ZigBee Alliance
 para aplicações de baixa taxa de transmissão de dados e de curto alcance
\begin_inset CommandInset citation
LatexCommand cite
key "alliance2007"

\end_inset

.
 É uma especificação para um conjunto de rede, segurança, e camadas de software
 de aplicações baseado no padrão IEEE 802.15.4 para redes de área pessoal
 (PAN)
\begin_inset CommandInset citation
LatexCommand cite
key "hwang2012"

\end_inset

.
\end_layout

\begin_layout Standard
A pilha do protocolo ZigBee é composta de quatro camadas principais: a camada
 física (PHY), a camada de controle de acesso ao meio (MAC), a camada de
 rede (NWK), e a camada de aplicação (APL).
 PHY e MAC de ZigBee são definidos pela norma IEEE 802.15.4, enquanto o resto
 da pilha é definido pela especificação ZigBee.
\end_layout

\begin_layout Standard
ZigBee é especialmente adequado para aplicações em sensores, incluindo automação
 predial, interruptores de luz sem fio, medidores elétricos e sistemas de
 gestão de tráfego.
 Em geral, é indicado para aplicações em que altas taxas de transferências
 de dados não são requeridas.
 A versão inicial do IEEE 802.15.4, em que ZigBee é baseado, atua nas frequências
 de 868MHz, 915 MHz e 2,4 GHz, que estão disponíveis na Europa, América
 do Norte e em todo o mundo, respectivamente.
 As taxas de dados são 20 kb/s, 40kb/s, e 250kb/s, respectivamente
\begin_inset CommandInset citation
LatexCommand cite
key "gomez2010wireless"

\end_inset

.
\end_layout

\begin_layout Standard
Os perfis de aplicações ZigBee mais importantes são o 
\emph on
ZigBee Home Automation Public Application Profile
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "alliance2007"

\end_inset

 e do 
\emph on
ZigBee Smart Energy
\emph default
 Profile
\begin_inset CommandInset citation
LatexCommand cite
key "alliance11smart"

\end_inset

.
 As principais áreas de aplicação para o perfil 
\emph on
Home Automation
\emph default
 são de iluminação, controle de temperatura, e segurança.
 O perfil 
\emph on
Smart Energy
\emph default
 lida com aplicações de gerenciamento de demanda de energia e de gestão
 de carga para as redes de energia.
\end_layout

\begin_layout Subsubsection
Bluetooth
\end_layout

\begin_layout Standard
Bluetooth, definido pela norma IEEE 802.15.1
\begin_inset CommandInset citation
LatexCommand cite
key "Bluetooth2004"

\end_inset

 foi inventado pelo provedor de telecomunicações Ericsson em 1994, e foi
 originalmente concebido como uma alternativa sem fios para a comunicação
 por fios RS-232.
 É um protocolo projetado principalmente para baixo consumo de energia com
 um curto alcance.
 Opera mundialmente através de uma banda de frequência não licenciada (ISM)
 em 2.4 GHz (2400-2483,5 MHz), com taxas de transmissão de 1 Mbit/s 
\begin_inset CommandInset citation
LatexCommand cite
key "Haartsen:1998"

\end_inset

.
 A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth_stack"

\end_inset

 apresenta a pilha do protocolo Bluetooth.
\end_layout

\begin_layout Standard
O sistema Bluetooth provê conexões ponto-a-ponto (apenas dois dispositivos
 Bluetooth envolvidos), ou conexões ponto-multiponto.
 Nas conexões ponto-multiponto, o canal é compartilhado entre alguns dispositivo
s Bluetooth, formando uma piconet.
 Em uma piconet, um dos dispositivos Bluetooth funciona como master (mestre),
 enquanto os demais funcionam como slaves (escravos).
 O master controla o acesso dos dispositivos slaves, determina o clock responsáv
el pela sincronização, dentre outras funções.
\end_layout

\begin_layout Standard
A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth_net"

\end_inset

 apresenta alguns exemplos de topologias possíveis.
 Em 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth_stack"

\end_inset

a, tem-se uma piconet com um único escravo.
 Em 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth_stack"

\end_inset

b, tem-se uma piconet com múltiplos escravos.
 Em 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:bluetooth_stack"

\end_inset

c, tem-se uma possível configuração de uma scatternet
\begin_inset CommandInset citation
LatexCommand cite
key "BluetoothSpecv1"

\end_inset

.
\end_layout

\begin_layout Standard
Bluetooth suporta ligações síncronas e assíncronas.
 O link síncrono orientado a conexão (SCO) é usado principalmente para voz
 e eles são transmitidos através de intervalos reservados.
 O link para conexão assíncrona (ACL) é usado principalmente para transmissão
 de dados.
 Ligação ACL pode utilizar as faixas restantes no canal.
 Ao contrário de SCO, para garantir a integridade de dados, no ACL pacotes
 são retransmitidos.
\end_layout

\begin_layout Standard
Existem três diferentes classes de dispositivos Bluetooth.
 Cada classe tem uma potência de transmissão diferente (daí um alcance de
 transmissão diferente)
\begin_inset CommandInset citation
LatexCommand cite
key "BluetoothCore"

\end_inset

:
\end_layout

\begin_layout Itemize
Classe 1: O alcance de comunicação é de 100 metros e a potência de transmissão
 é de 100 mW (20 dBm)
\end_layout

\begin_layout Itemize
Classe 2: O alcance de comunicação é de 50 metros e a potência de transmissão
 é de 2,5 mW (4 dBm)
\end_layout

\begin_layout Itemize
Classe 3: O alcance de comunicação é de 10 metros e a potência de transmissão
 é de 1 mW (0 dBm)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/bluetooth_stack.png
	width 40line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pilha do protocolo Bluetooth 
\begin_inset CommandInset citation
LatexCommand cite
key "BluetoothCore"

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:bluetooth_stack"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/bluetooth_net.svg
	width 60line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Topologias de redes Bluetooth
\end_layout

\end_inset

Topologias de redes Bluetooth (traduzido de 
\begin_inset CommandInset citation
LatexCommand cite
key "BluetoothSpecv1"

\end_inset

) 
\begin_inset CommandInset label
LatexCommand label
name "fig:bluetooth_net"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Bluetooth LE (Low Energy)
\end_layout

\begin_layout Standard
Bluetooth 
\emph on
Low Energy
\emph default
, definido em 
\emph on
Bluetooth Core Spec 4.0
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "bluetooth2010"

\end_inset

 e suas derivações 4.1 e 4.2, é um protocolo sem fio operando na banda não
 licenciada de 2,4 GHz.
 Enquanto ela opera na mesma faixa de frequência que outras tecnologias
 Bluetooth, a sua operação nas camadas físicas (PHY) é incompatível, necessitand
o de dispositivos com chipsets operem nos dois modos (Dual-mode)
\begin_inset CommandInset citation
LatexCommand cite
key "bluetooth2010"

\end_inset

.
 A camada PHY BT.LE usa 
\emph on
Gaussian Frequency Shift Keying
\emph default
 (FSK) com um deslocamento de 250 kHz.
 Ele transmite em um dos 40 canais em 1 Mbit/s.
\end_layout

\begin_layout Standard
Segundo a Bluetooth SIG (Special Interest Group), o Bluetooth LE, destaca-se
 como uma importante tecnologia para a Internet das Coisas:
\end_layout

\begin_layout Quote
Bluetooth 4.2 is an important update to the Bluetooth Core Specification
 delivering exciting new features and benefits for Bluetooth Smart.
 This will create significant advantages for developers and manufacturers,
 while providing a better user experience for their customers.
 Bluetooth 4.2 makes Bluetooth Smart even smarter, faster and the ideal wireless
 technology for the Internet of Things (IoT).
\begin_inset CommandInset citation
LatexCommand cite
key "bluetooth2010:site"

\end_inset


\end_layout

\begin_layout Standard
Resumidamente as diferenças de aplicação entre as versões são destacadas
 a seguir:
\end_layout

\begin_layout Itemize
Bluetooth BR/EDR (2.0/2.1): Estabelece uma distância relativamente curta,
 conexão sem fio contínua, o que o torna ideal para os casos de uso, tais
 como streaming de áudio.
 
\end_layout

\begin_layout Itemize
Bluetooth LE (4.0): Rajadas de conexão de rádio de longo alcance, tornando-o
 ideal para a Internet das Coisas (IoT), aplicações que não necessitam de
 conexão contínua, mas dependem de longa duração da bateria.
\end_layout

\begin_layout Subsubsection
Z-WAVE 
\end_layout

\begin_layout Standard
Z-Wave é uma tecnologia desenvolvida pela Zensys e padronizado pela Z-Wave
 Alliance, para automação em ambientes residenciais e comerciais.
 Ela usa um rádio RF de baixa potência para aplicações de controle remoto.
 O principal objetivo do Z-Wave é permitir transmissão de mensagens curtas
 com consistência a partir de uma unidade de controle a um ou mais nós na
 rede
\begin_inset CommandInset citation
LatexCommand cite
key "zwave:protocol2006"

\end_inset

.
 Topologias de malha podem ser formadas, no entanto, o esquema de endereçamento
 utilizado permite um máximo de 232 nós na rede.
\end_layout

\begin_layout Standard
O rádio Z-Wave atua principalmente em 900 MHz (868 MHz na Europa e 908 MHz
 nos Estados Unidos) e 2,4 GHz, com taxas de dados entre 9,6 kbps e 40 kbps,
 e o alcance do sinal efetivo é de 30 metros em ambientes fechados e é capaz
 de exceder a 100 metros ao ar livre, adequado para aplicações com baixa
 taxa de transmissão de dados.
 À media que a distância da comunicação aumenta, o mesmo ocorre com a complexida
de do dispositivo, o consumo de energia e os custos do sistema.
 Um característica do chip de comunicação Z-Wave, é que ele pode ser colocado
 no estado de dormência num longo período de tempo, gerando um baixo consumo
 de energia, proporcionando uma maior duração da bateria para os dispositivos.
\end_layout

\begin_layout Standard
Embora atualmente o Z-Wave seja mais popular do que ZigBee para aplicações
 de automação residencial, muitos especialistas do setor advertem
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
ref
\end_layout

\end_inset

 que Z-Wave sofre de algumas limitações fundamentais quando comparado com
 ZigBee, já que Zigbee tem latência mais baixa (10 ms) e maior taxa de transferê
ncia do que Z-Wave (latência de 100 ms).
 Embora o Z-Wave tenha capacidade de redes mesh, este mecanismo não é tão
 robusto quanto ZigBee.
 
\end_layout

\begin_layout Standard
O Z-Wave define dois tipos de dispositivos: controladores e escravos.
 Controladores fazem requisições ou enviam comandos para os escravos, que
 respondem aos controladores ou executam os comandos recebidos.
\end_layout

\begin_layout Subsection
Tecnologias IP
\end_layout

\begin_layout Subsubsection
Wi-Fi 
\end_layout

\begin_layout Standard
O objetivo do padrão IEEE 802.11
\begin_inset CommandInset citation
LatexCommand cite
key "ieee1997wireless"

\end_inset

 é fornecer conectividade sem fio para dispositivos que requerem uma instalação
 rápida, como computadores portáteis, PDAs ou dispositivos geralmente móveis
 dentro de uma WLAN (Wireless Local Area Rede).
\end_layout

\begin_layout Standard
A rede IEEE 802.11 é uma especificação de rede local sem fio (WLAN).
 No seu modo de banda baixa, IEEE 802.11 (b, g, n), pode transmitir dados
 de 11 Mbps até 54Mbps e vai até 32 metros em ambientes fechados e 95 metros
 ao ar livre
\begin_inset CommandInset citation
LatexCommand cite
key "Garroppo2011"

\end_inset

.
 O padrão IEEE 802.11n utiliza o dobro do espectro de frequência em comparação
 com 802.11a ou 802.11g.
 No entanto, IEEE 802.11a, pode operar com uma taxa de transmissão de até
 Gbps e pode exceder a faixa por mais de duas vezes do que os padrões 'b'
 e 'g'.
 No modo de banda baixa, o Wi-Fi transmite na faixa não licenciada (ISM)
 de 2,4 GHz, enquanto a banda alta transmitir na faixa de 5 GHz.
\end_layout

\begin_layout Standard
Um novo padrão Wi-Fi, 802.11ah, na banda não licenciada de 900 MHz, para
 aplicações de automação residencial e predial é esperado chegar ao mercado
 ainda este ano
\begin_inset CommandInset citation
LatexCommand cite
key "wifi:zigbee"

\end_inset

.
 Ele estará competindo com outros protocolos já estabelecidos nesta banda,
 como o ZigBee.
 WiFi AH visa apoiar uma gama de opções de taxa de transferência de 150Kbits
 com uma banda de 1MHz a até 40Mbits sobre uma banda de 8MHz.
 Espera-se também cobrir distâncias de 50% a mais do que outros produtos
 802.11n.
\end_layout

\begin_layout Standard
O padrão 802.11af
\begin_inset CommandInset citation
LatexCommand cite
key "IEEE80211ah"

\end_inset

, também chamado de Super Wi-Fi ou White-Fi, emprega o espectro de frequências
 de TV não utilizadas, entre 54 MHz e 790MHz, em intervalos muito longos
 (possivelmente vários quilômetros).
 Pode oferecer rendimento razoável, talvez 24MB/s.
 Tem aplicações semelhantes ao 802.11ah, também conhecido como Low Power
 Wi-Fi, que irá fornecer largura de banda para sensores e monitores em gadgets
 e aparelhos que irão juntar-se para criar a Internet das Coisas.
\end_layout

\begin_layout Subsubsection
6LoWPAN
\end_layout

\begin_layout Standard
6LoWPAN é uma definição de protocolo que descreve como utilizar IPv6 em
 cima de uma rede de baixo consumo de energia, baixa taxa de dados, redes
 sem fio de área pessoal (WAN) e de baixo custo 
\begin_inset CommandInset citation
LatexCommand cite
key "ZShelby2009"

\end_inset

.
 Os nós no 6LoWPAN são ligados em uma topologia de estrela ou de malha e
 com suporte a taxas de transmissão de dados de 20 a 250kbps a uma distância
 de cerca de dez metros
\begin_inset Note Note
status open

\begin_layout Plain Layout
checar!
\end_layout

\end_inset

.
 Projetado para enviar pacotes IPv6 sobre redes baseadas em IEEE
\begin_inset space ~
\end_inset

802.15.4 e implementar padrões IP abertos, incluindo TCP, UDP, HTTP, COAP,
 MQTT e websockets.
\end_layout

\begin_layout Standard
Esta norma é desenvolvida para que os dispositivos de sensores sem fio possam
 se conectar a redes IP existentes, como redes IPv4, sem a necessidade de
 gateways de tradução ou proxy
\begin_inset CommandInset citation
LatexCommand cite
key "ZShelby2009"

\end_inset

.
 A camada física padrão 6LoWPAN é baseado em IEEE
\begin_inset space ~
\end_inset

802.15.4 (PHY) com 868/914 MHz ou 2,4 GHz rádio.
 A sub-camada MAC 6LoWPAN é totalmente compatível com IEEE 802.15.4 MAC
\begin_inset CommandInset citation
LatexCommand cite
key "molisch2004ieee"

\end_inset

.
 A estrutura de pilha 6LoWPAN está ilustrada na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:6LoWPAN"

\end_inset

.
 Na pilha de protocolos, a camada de ligação está dividida em sub-camada
 IEEE
\begin_inset space ~
\end_inset

802.15.4
\begin_inset space ~
\end_inset

MAC e da camada de adaptação 6LoWPAN
\begin_inset CommandInset citation
LatexCommand cite
key "ZShelby2009"

\end_inset

.
\end_layout

\begin_layout Standard
Em termos de roteamento da camada IP, 6LoWPAN suporta protocolos tais como
 protocolos de roteamento de baixa potência e redes com perdas (RPL)
\begin_inset CommandInset citation
LatexCommand cite
key "hui2012routing"

\end_inset

, que atenua problemas, tais como estatísticas de link não determinísticos
 e falta de visibilidade sobre topologia física.
 6LoWPAN suporta segurança apenas da camada de enlace através de criptografia
 de 128 bits AES (Advanced Encryption Scheme).
 A coexistência com outros dispositivos, tais como Wi-Fi, não é eficiente,
 por causa da utilização de mesmo canal por todos os dispositivos.
 Alguns dispositivos podem tirar vantagem ao usar o rádio de 2,4 GHz, mas,
 mesmo assim, apenas três (15, 20 e 25) dos dezesseis canais vão evitar
 interferências
\begin_inset CommandInset citation
LatexCommand cite
key "angrisani2008experimental"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/6LoWPAN_1.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pilhas do protocolo IP e 6LoWPAN 
\begin_inset CommandInset citation
LatexCommand cite
key "ZShelby2009"

\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "fig:6LoWPAN"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Preciso realizar mais estudos para implementar no OpenDevice
\end_layout

\end_inset


\end_layout

\begin_layout Section
Protocolos
\end_layout

\begin_layout Standard
Nesta seção serão abordados os principais protocolos de comunicação utilizados
 para a construção de aplicações IoT.
 Embora não exista um protocolo definido para a Internet das Coisas, devido
 sua ampla área de atuação e requisitos, várias propostas estão disponíveis
 na literatura e no mercado.
 A seguir abordaremos com mais detalhes estes protocolos.
\end_layout

\begin_layout Subsection
REST
\end_layout

\begin_layout Standard
O REST - 
\emph on
Representational State Transfer
\emph default
, ou, em tradução livre, Transferência de Estado Representativo, é uma técnica
 de engenharia de software criado pelo Dr.
 Roy Fielding
\begin_inset CommandInset citation
LatexCommand cite
key "fielding2000architectural"

\end_inset

, um dos autores da especificação do HTTP.
 Esta técnica foi criada para trabalhar em sistemas distribuídos como o
 próprio WWW (Word Wide Web).
 REST define como o design da aplicação se comportará: uma rede de websites
 (um estado virtual), onde o usuário progride com uma aplicação selecionando
 as ligações (transições do estado), tendo como resultado a página seguinte
 (que representa o estado seguinte da aplicação) que está sendo transferida
 ao usuário e apresentada para seu uso
\begin_inset CommandInset citation
LatexCommand cite
key "fielding2000architectural"

\end_inset

.
 Cada recurso possui um identificador único, chamado URI (Universal Resource
 Indicators), que permite o acesso a tais recursos através de uma URL.
 
\end_layout

\begin_layout Standard
Um recurso é um mapeamento conceitual para um conjunto de entidades, que
 segundo 
\begin_inset CommandInset citation
LatexCommand cite
key "ibm:rest"

\end_inset

 “os clientes não acessam os recursos diretamente, mas, em vez disso, uma
 representação do recurso através de uma interface uniforme”.
 Tais recursos são apresentados, geralmente, em XML ou JSON.
 A abstração chave da informação em REST é um recurso.
 Qualquer informação que pode ser chamada pode ser um recurso: um documento
 ou uma imagem, um serviço temporal (por exemplo, "o tempo de hoje em Los
 Angeles"), uma coleção de outros recursos, um objeto não-virtual (por exemplo,
 uma pessoa), e assim por diante.
 Em outras palavras, qualquer conceito que pode ser o alvo de referência
 de hipertexto de um autor deve caber dentro da definição de um recurso.
 Um recurso é um mapeamento conceptual para um conjunto de entidades 
\begin_inset CommandInset citation
LatexCommand cite
key "fielding2000architectural"

\end_inset

.
\end_layout

\begin_layout Standard
O sucesso desta técnica de engenharia de software, aplicado na arquitetura
 cliente-servidor, é devido à possibilidade de separar do servidor, a responsabi
lidade de montar a interface de apresentação de dados aos clientes.
 Dessa forma as aplicações podem migrar para uma série de plataformas, independe
nte dos servidores.
 A separação de interesses é o princípio por trás das restrições de cliente-serv
idor.
 Ao separar as preocupações da interface de usuário das preocupações de
 armazenamento de dados, podemos melhorar a portabilidade da interface do
 usuário através de múltiplas plataformas e melhorar a escalabilidade, simplific
ando os componentes do servidor.
 Talvez o mais importante para a Web, no entanto, é que a separação permite
 que os componentes evoluam de forma independente, suportando, assim, a
 exigência da Internet escalar de vários domínios 
\begin_inset CommandInset citation
LatexCommand cite
key "fielding2000architectural"

\end_inset

.
\end_layout

\begin_layout Standard
Como já citado, os recursos acessados por uma aplicação REST são apresentados
 em representações de dados, geralmente, identificado por um par, nome e
 valor.
 A representação consiste em metadados que descrevem os dados e, em certas
 ocasiões, metadados para descrever metadados (geralmente com a finalidade
 de verificar a integridade da mensagem).
 Metadados são na forma de pares nome-valor, onde o nome corresponde a um
 padrão que define a estrutura e semântica do valor.
 As mensagens de resposta podem incluir tanto metadados representativos
 quanto metadados de recursos: informações sobre o recurso que não é específico
 para a representação fornecida 
\begin_inset CommandInset citation
LatexCommand cite
key "fielding2000architectural"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A estrutura do texto está muito burocrática...
 melhores exemplos
\end_layout

\begin_layout Plain Layout
http://run.unl.pt/bitstream/10362/2079/1/Ngolo_2009.pdf
\end_layout

\begin_layout Plain Layout
file:///home/ricardo/Downloads/22140-81565-1-PB.pdf
\end_layout

\begin_layout Plain Layout
https://repositorio-aberto.up.pt/bitstream/10216/281/2/51002.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
WebSocket
\end_layout

\begin_layout Standard
O WebSocket é uma tecnologia que permite a comunicação entre cliente e servidor
 de forma bidirecional (full-duplex), sobre um único soquete TCP.
 Foi desenvolvido para clientes HTTP com suporte a HTML5, entretanto, seu
 uso pode se estender a qualquer aplicação cliente-servidor
\begin_inset CommandInset citation
LatexCommand cite
key "Salim2013,Fette2011"

\end_inset

.
 
\end_layout

\begin_layout Standard
Devido ao fato de realizar um único pedido de conexão, e esta conexão ser
 full-duplex, o servidor não precisa esperar uma requisição do cliente para
 o envio de dados.
 Da mesma forma, o cliente pode enviar informações a qualquer momento para
 o servidor.
 Isto causa uma redução significativa da latência, comparando a um 
\emph on
Polling
\emph default
 HTTP (requisições de tempos em tempos).
 A comparação entre os mecanismo tradicional usando 
\emph on
Polling e usando 
\emph default
WebSocket, na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:websocket"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/websocket_polling.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparação de comunicação entre Pulling e WebSocket 
\begin_inset CommandInset citation
LatexCommand cite
key "Salim2013"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:websocket"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
O protocolo WebSocket é executado em duas etapas.
 A primeira é uma mensagem de handshake (aperto de mão), onde tanto o cliente
 quanto o servidor enviam suas respectivas informações.
 Após um handshake bem sucedido, se inicia a transferência de dados.
 
\end_layout

\begin_layout Standard
Segundo 
\begin_inset CommandInset citation
LatexCommand cite
key "Fette2011"

\end_inset

, os dados são transferidos em unidades conceituais denominadas mensagens,
 onde estas não necessariamente representam 
\emph on
frames
\emph default
 da camada de rede.
 Neste caso um 
\emph on
frame
\emph default
 possui um tipo associado, e cada 
\emph on
frame
\emph default
 pertence à mesma mensagem, contendo o mesmo tipo de dados.
 Existem, de forma geral, três tipos de dados específicos.
 São eles (1) os dados textuais, interpretados em UTF-8; (2) dados binários,
 interpretados pela aplicação, e (3) 
\emph on
frames
\emph default
 de controle, responsáveis pelas sinalizações em nível de protocolo, como
 informar que a conexão deve ser fechada.
 
\end_layout

\begin_layout Subsection
CoAP
\end_layout

\begin_layout Standard
O CoAP, acrônimo de Constrained Application Protocol, é um protocolo da
 camada de aplicação leve e facilmente mapeável que tem como finalidade,
 projetar um protocolo web genérico para necessidades especificas de ambientes
 com restrições de recursos, tais como, memória, energia ou processamento.
 Sua tecnologia objetiva reduzir, ao máximo possível, o tamanho das mensagens
 utilizadas em sua comunicação
\begin_inset CommandInset citation
LatexCommand cite
key "Shelby2014"

\end_inset

.
 
\end_layout

\begin_layout Standard
O CoAP foi criado em 2010 por um grupo de trabalho do IETF (Internet Engineering
 Task Force) chamado CoRE (Constrained RESTful Environments)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://datatracker.ietf.org/wg/core/charter/
\end_layout

\end_inset

, com objetivo de prover um framework para aplicações que manipulam recursos
 simples localizados em dispositivos interligados em redes limitadas, incluindo
 desde aplicações que monitoram sensores de temperatura e medidores de energia,
 até controle de atuadores como interruptores ou trancas eletrônicas, e
 também aplicações que gerenciam os dispositivos que compõem a rede
\begin_inset CommandInset citation
LatexCommand cite
key "coap:ietf2016"

\end_inset

.
\end_layout

\begin_layout Standard
O CoAP baseia-se na abordagem de arquitetura REST, projetado para o mapeamento
 fácil e sem estado (stateless) com o HTTP, e para proporcionar interação
 M2M.
 A compatibilidade com HTTP é obtida através da manutenção do mesmo modelo
 de interação, mas utilizando um subconjunto dos métodos HTTP
\begin_inset CommandInset citation
LatexCommand cite
key "Shelby2014"

\end_inset

.
\end_layout

\begin_layout Standard
Principais características definidas pela especificação:
\end_layout

\begin_layout Itemize
Protocolo Web que cumpre com os requerimentos M2M em ambientes restritos;
\end_layout

\begin_layout Itemize
Troca de mensagens assíncrona;
\end_layout

\begin_layout Itemize
Suporte à URI e Content-Type;
\end_layout

\begin_layout Itemize
Capacidades simples de proxy e caching;
\end_layout

\begin_layout Itemize
Mapeamento HTTP que permite que proxies possam prover acesso aos recursos
 do CoAP via HTTP de maneira uniforme;
\end_layout

\begin_layout Itemize
Interligação segura usando Datagram Transport Layer Security (DTLS);
\end_layout

\begin_layout Itemize
Ligação em UDP com confiabilidade opcional suportando requisições tanto
 unicast quanto multicast;
\end_layout

\begin_layout Itemize
Suporte aos métodos GET, POST, PUT, DELETE.
\end_layout

\begin_layout Standard
A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:coap"

\end_inset

 ilustra a arquitetura CoAP em uma perspectiva de alto nível.
 Um dos objetivos do CoRE também consiste em adequar a arquitetura REST,
 para ambientes restritos, composto por nós (ex.: microcontroladores 8-bits
 com memória limitada) e redes (ex.: 6LoWPAN e RFC4944
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://tools.ietf.org/html/rfc4944
\end_layout

\end_inset

).
 O CoAP foi desenvolvido de acordo com esta arquitetura, logo pode ser considera
do como um protocolo RESTful
\begin_inset CommandInset citation
LatexCommand cite
key "Shelby2014"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/coap.png
	width 80line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visão geral da arquitetura CoAP 
\begin_inset CommandInset citation
LatexCommand cite
key "img:Shelby2014"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:coap"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
MQTT
\end_layout

\begin_layout Standard
O protocolo MQTT (MQ Telemetry Transport)
\begin_inset CommandInset citation
LatexCommand cite
key "mqtt:spec"

\end_inset

, é um protocolo leve, baseado em mensagens seguindo o padrão 
\emph on
publish/subscribe,
\emph default
 executado sobre TCP/IP, usado para sensores remotos e controle de dispositivos
 em ambientes com restrições como redes de baixa largura de banda, pouco
 confiáveis ou comunicações intermitentes, principalmente encontrados em
 contextos Machine to Machine (M2M) e Internet das Coisas (IoT).
 O protocolo foi projetado para ser aberto, simples, leve e fácil de implementar.
 Estas características o fazem ideal para ser utilizando em ambientes e
 dispositivos com restrições de memória e largura de banda, mas não limitados
 a estes.
\end_layout

\begin_layout Standard
O MQTT foi criado em meados de 1999 por Andy Stanford-Clark (IBM) e Arlen
 Nipper (Eurotech).
 Atualmente, na versão 3.1.1, a especificação do MQTT faz parte dos padrões
 OASIS
\begin_inset CommandInset citation
LatexCommand cite
key "mqtt:oasis"

\end_inset

.
 O MQTT, na sua essência, compartilha algumas características com o CoAP:
\end_layout

\begin_layout Itemize
São padrões abertos; 
\end_layout

\begin_layout Itemize
São mais adequadas para ambientes com restrições;
\end_layout

\begin_layout Itemize
Fornecem mecanismos para comunicação assíncrona; 
\end_layout

\begin_layout Itemize
Executam sobre a pilha IP;
\end_layout

\begin_layout Itemize
Têm uma série de implementações.
\end_layout

\begin_layout Subsubsection
Arquitetura
\end_layout

\begin_layout Standard
O protocolo segue o padrão publish/subscribe (pub/sub), que é uma alternativa
 para o modelo cliente-servidor tradicional, onde um cliente se comunica
 diretamente com um ponto final.
 No entanto, o padrão publish/subscribe desacopla um cliente, que está enviando
 uma mensagem particular (chamado nesse caso de publisher) de outro cliente
 (ou mais), que está recebendo a mensagem (chamado subscriber).
 Isto significa que o 
\emph on
publisher
\emph default
 e 
\emph on
subscriber,
\emph default
 não sabem da existência do outro.
 Há um terceiro componente, chamado de 
\emph on
broker
\emph default
, que é conhecido tanto pelo 
\emph on
publisher
\emph default
 quando pelo 
\emph on
subscriber
\emph default
, que filtra todas as mensagens recebidas e distribui de forma adequada.
 
\end_layout

\begin_layout Standard
As mensagens a serem transmitidas são publicadas para um endereço (chamado
 de tópico), que assemelha-se a um sistema de arquivos, por exemplo, 
\emph on
casa/sala/temperatura
\emph default
.
 Clientes por sua vez podem se subscrever para vários tópicos, tornando-se
 assim capazes de receber as mensagens que outros clientes publicam neste
 tópico.
 A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mqtt"

\end_inset

 mostra uma rede de três clientes conectados com um broker central.
 Quando o cliente 
\begin_inset Quotes eld
\end_inset


\emph on
MyTopicPublish
\emph default

\begin_inset Quotes erd
\end_inset

, envia uma mensagem para o tópico 
\begin_inset Quotes eld
\end_inset


\emph on
MyTopic
\emph default

\begin_inset Quotes erd
\end_inset

, todos os interessados (
\emph on
subscriber
\emph default
s) recebem esta mensagem.
\end_layout

\begin_layout Standard
O MQTT não define o tipo dos dados contidos na mensagem (playload), o 
\emph on
publisher
\emph default
 pode enviar dados binários, dados textuais ou dados estruturados como XML
 e JSON.
 Uma mensagem MQTT também tem mais alguns atributos, que nós vamos discutir
 em detalhes a seguir.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/mqtt_broker.png
	width 80line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Padrão MQTT - Publish/Subscribe 
\begin_inset CommandInset citation
LatexCommand cite
key "img:mqtt:oracle"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:mqtt"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Formato da Mensagem
\end_layout

\begin_layout Standard
As mensagens MQTT possuem um cabeçalho fixo composto de dois bytes, campos
 opcionais de cabeçalhos variáveis e conteúdo da mensagem (playload).
 Os cabeçalhos opcionais e playload dependem do tipo da mensagem transmitida.
 A figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mqtt-1"

\end_inset

 mostra o formato das mensagens MQTT.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/mqtt_message.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Formato da mensagem MQTT 
\begin_inset CommandInset citation
LatexCommand cite
key "img:mqtt:peter"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:mqtt-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
No primeiro byte do cabeçalho fixo, os quatro primeiros bits representam
 o tipo de mensagem, conforme a tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mqtt"

\end_inset

, e os quatro bits restantes são descritos a seguir:
\end_layout

\begin_layout Itemize

\series bold
Duplicate delivery (DUP)
\series default
: acrônimo relativo à entrega duplicada, este marcador ocupa o bit 4 e é
 ativado quando o cliente ou o servidor tentam reenviar mensagens do tipo
 
\emph on
PUBLISH, PUBREL, SUBSCRIBE
\emph default
 ou 
\emph on
UNSUBSCRIBE
\emph default
, que tenham QoS > 0.
\end_layout

\begin_layout Itemize

\series bold
Quality of Service (QoS)
\series default
: este marcador ocupa os bits 5 e 6, e indica o nível de garantia da entrega
 de uma mensagem 
\emph on
PUBLISH
\emph default
.
 Os níveis de QoS são mostrados na tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mqtt_qos"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
RETAIN
\series default
: quando um cliente envia uma mensagem 
\emph on
PUBLISH
\emph default
 ao servidor com este marcador ativado, ela deve ser retida no servidor
 mesmo depois de ser entregue aos assinantes.
 No ocasião de uma nova subscrição a um tópico, a última mensagem retida
 para este tópico deve ser enviada para o novo assinante.
\end_layout

\begin_layout Standard
A largura restante do cabeçalho fixo (byte 2) é usada para representar a
 quantidade de bytes remanescentes na mensagem.
 Incluindo dados do cabeçalho variável e do payload.
 
\end_layout

\begin_layout Standard
O cabeçalho variável é um componente presente em alguns tipos de mensagem
 MQTT e está localizado entre o cabeçalho fixo e o payload.
\end_layout

\begin_layout Standard
O payload pode armazenar diferentes tipos de informações, tudo vai depender
 do tipo da mensagem transmitida: CONNECT (irá conter ID do cliente), SUBSCRIBE
 (contém tópicos que o cliente deseja subscrever) ou SUBACK (lista de níveis
 de QoS garantidos pelo servidor).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mnemônico
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Código
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Descrição
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reservado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reservado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CONNECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requisição de conexão do cliente ao servidor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CONNACK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ACK de conexão
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUBLISH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Publicação de mensagem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUBACK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ACK de publicação
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUBREC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Publicação recebida (garantia de entrega parte I)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUBREL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Publicação liberada (garantia de entrega parte II)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PUBCOMP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Publicação completa (garantia de entrega parte III)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUBSCRIBE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requisição de subscrição do cliente
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUBACK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ACK de subscrição
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UNSUBSCRIBE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requisição de cancelamento de subscrição do cliente
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UNSUBACK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ACK de cancelamento de subscrição
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PINGREQ
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requisição PING
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PINGRESP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resposta PING
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DISCONNECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cliente desconectando
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reservado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reservado
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
MQTT - Tipos de mensagem 
\begin_inset CommandInset citation
LatexCommand cite
key "mqtt:spec"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:mqtt"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Valor QoS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bit 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Descrição
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Até uma vez (Disparar e esquecer)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ao menos uma vez (Entrega com ACK)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entrega garantida
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reservado
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
MQTT - Níveis de QoS 
\begin_inset CommandInset citation
LatexCommand cite
key "mqtt:spec"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:mqtt_qos"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Middleware
\begin_inset CommandInset label
LatexCommand label
name "sub:Fund_Middleware"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Como citado anteriormente, o paradigma de IoT ainda possui diversos desafios
 em aberto que requerem soluções em nível de hardware e de software.
 Em particular, faz-se necessária uma camada de software que forneça abstrações
 para dispositivos e aplicações, diversos níveis de transparência e interoperabi
lidade, bem como múltiplos serviços para usuários finais e aplicações.
 Essa camada de software, denominada middleware, oculta dos desenvolvedores
 de aplicações as complexidades e heterogeneidades referentes ao hardware
 subjacente, às camadas de protocolos de rede, às plataformas e dependências
 do sistema operacional, além de facilitar o gerenciamento de recursos do
 sistema e aumentar a previsibilidade da execução de aplicações [Bernstein
 1996].
 
\end_layout

\begin_layout Plain Layout
---
\end_layout

\begin_layout Plain Layout
No contexto de IoT, uma plataforma de middleware representa um artefato
 de software residindo entre a camada de aplicação e a infraestrutura de
 suporte (comunicação, processamento, sensoriamento), fornecendo acesso
 padronizado aos dados e serviços providos pelos objetos inteligentes através
 de interfaces de alto nível, além de promover o reuso de serviços genéricos,
 que podem ser compostos e configurados para facilitar o desenvolvimento
 de aplicações de forma mais eficiente para o ambiente de IoT.
 O desenvolvimento de plataformas de middleware para IoT tem atraído cada
 vez mais a atenção da comunidade acadêmica e da indústria.
 Por conta disso, diversas pesquisas já foram reportadas na literatura visando
 a concepção e a implementação de plataformas de middleware abordando os
 requisitos mencionados anteriormente.
 As subseções a seguir apresentam algumas propostas de plataformas de middleware
 para IoT e como tais plataformas procuram atender aos requisitos levantados
 na Seção 3.2.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Falta os requisitos do Middleware: 3.2.
 Requisitos de Middleware para IoT (Plataformas para a Internet das Coisas.pdf)
\end_layout

\begin_layout Plain Layout
Assisitir: https://www.youtube.com/watch?v=7s_S5Hkm7z0&list=PLlqhIsxvN4u5DMCtupY9-
aL2mVRnK-pTz&index=3
\end_layout

\begin_layout Plain Layout
Talvez seja interessante falar das especificações omo OneM2M e as da ETSI
\end_layout

\begin_layout Plain Layout
- OM2M: Extensible ETSI-compliant M2M service platform with self-configuration
 capability.pdf
\end_layout

\begin_layout Plain Layout
- http://www.etsi.org/technologies-clusters/technologies/m2m (Standards)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
É uma camada de software que lida com a execução e desenvolvimento de aplicações
 distribuídas.
 Localiza-se entre o Sistema Operacional (SO) e a aplicação abstraindo a
 complexidade e a heterogeneidade dos elementos do sistema, além de coordenar
 como eles interagem entre si
\begin_inset CommandInset citation
LatexCommand cite
key "mahmoud2004middleware"

\end_inset

.
 Basicamente, utiliza mecanismos de comunicação de baixo nível com a infraestrut
ura, para assim fornecer uma comunicação de alto nível para as aplicações.
 Os middlewares podem ser classificados em diversas categorias, e essas
 categorias estão baseadas, por exemplo, na abstração fornecida para a programaç
ão da comunicação (tuplas distribuídas, procedimentos, mensagens e objetos
 distribuídos), em como as entidades se comunicam (cliente/servidor, ponto-a-pon
to e publish/subscribe), e no tipo de comunicação (síncrona, assíncrona).
 
\end_layout

\begin_layout Subsection
Componentes do Middleware de IoT
\end_layout

\begin_layout Standard
Bandyopadhyay, S.
 et.
 al.
 realizou estudos sobre sistemas de middleware que foram aplicados em sistemas
 baseados em IoT
\begin_inset CommandInset citation
LatexCommand cite
key "Bandyopadhyay2011"

\end_inset

.
 Eles classificam a funcionalidade necessária do middleware para gerenciar
 interações com uma variedade de dispositivos em quatro componentes funcionais,
 a saber: (1) protocolos de interface, (2) abstração de dispositivos, (3)
 de controle central, detecção e gerenciamento de contexto, e (4) abstração
 da aplicação (Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:middleware_bandyopadhyay"

\end_inset

).
 A seguir, vamos explicar estes componentes em detalhes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Imagens/Cap_2/middleware_bandyopadhyay.jpg
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Componente do Middleware de IoT 
\begin_inset CommandInset citation
LatexCommand cite
key "Bandyopadhyay2011"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:middleware_bandyopadhyay"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Traduzir figura, e colocar: adaptado e traduzido de (Abcdefghij et al., 2008)
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Protocolos de Interface
\end_layout

\begin_layout Standard
Este componente é responsável pelo fornecimento da 
\emph on
interoperabilidade técnica
\emph default
.
 Interoperabilidade no contexto de protocolos de interface significa: 
\emph on
a capacidade de dois sistemas interagirem utilizando os mesmos protocolos
 de comunicaçã
\emph default
o.
\end_layout

\begin_layout Standard
O componente de protocolo de interface define protocolos para a troca de
 informações entre as diferentes redes que podem funcionar com base em diferente
s protocolos de comunicação, a fim de permitir a interoperabilidade técnica.
 Este componente é responsável pelo tratamento de conectividade básica na
 ligação física e de dados, rede, transporte, e às vezes na camada de aplicação
 da pilha TCP / IP.
\end_layout

\begin_layout Standard
Para lidar com a heterogeneidade de dispositivos, podemos usar uma camada
 de abstração (wrapper) para cada dispositivo, para traduzir o protocolo
 suportado pelo dispositivo para um protocolo comum.
 Esta abstração pode ser colocada no lado do dispositivo ou do lado de middlewar
e.
 Se quisermos ter uma interação direta com dispositivos, devemos colocar
 a abstração no lado do middleware.
 Dispositivos normalmente têm capacidade limitada de processamento computacional
, pelo que esta seria uma razão para implementar a abstração no lado do
 middleware.
\end_layout

\begin_layout Subsubsection
Abstração de dispositivos (Device Abstraction)
\end_layout

\begin_layout Standard
Este componente é responsável pelo fornecimento de um formato abstrato para
 facilitar a interação dos componentes de aplicação com os dispositivos.
 Esta abstração fornece interoperabilidade sintáctica e semântica, que são
 definidos pelo ETSI
\begin_inset CommandInset citation
LatexCommand cite
key "ETSI2006"

\end_inset

, como segue:
\end_layout

\begin_layout Itemize

\emph on
Interoperabilidade sintática
\emph default
 está associada com formatos de dados.
 as mensagens transferido por protocolos de comunicação deve ter uma sintaxe
 bem definida e formato de codificação, o qual pode ser representado utilizando
 sintaxes de transferência de alto nível tais como, JSON e XML.
\end_layout

\begin_layout Itemize
A 
\emph on
interoperabilidade semântica
\emph default
 é geralmente associada com o significado do conteúdo da mensagem que é
 compreensível para todos envolvidos na comunicação.
 Assim, a interoperabilidade a este nível, significa que há um entendimento
 comum entre os componentes sobre o significado do conteúdo (informação)
 que estão sendo trocadas entre eles.
 Interoperabilidade semântica se baseia em modelos semânticos que tende
 a ser de domínio específico.
 Por exemplo, uma forma de oferecer interoperabilidade semântica em middlewares
 orientadas a serviços (SOA)
\begin_inset CommandInset citation
LatexCommand cite
key "w3c:soa"

\end_inset

 é usando 
\emph on
Devices Profile for Web Services
\emph default
 (DPWS)
\begin_inset CommandInset citation
LatexCommand cite
key "driscoll2009devices"

\end_inset

.
 Neste contexto, cada tipo de dispositivo refere-se a um tipo de serviço
 diferenciado.
\end_layout

\begin_layout Subsubsection
Controle Central, Detecção de Contexto e Gerenciamento
\end_layout

\begin_layout Standard
Contexto caracteriza a situação de uma entidade, que pode ser um lugar,
 uma pessoa ou um objeto que é relevante para o usuário, aplicações e suas
 interações 
\begin_inset CommandInset citation
LatexCommand cite
key "Bandyopadhyay2011"

\end_inset

.
 Este componente é responsável por suportar a computação baseada em contexto
 (context-aware)
\begin_inset CommandInset citation
LatexCommand cite
key "schilit1994context"

\end_inset

, que é um modelo computacional que levam em conta o contexto das entidades
 que interagem com o sistema.
 Um middleware para sistemas baseados em Internet das Coisas deve estar
 ciente de contexto para trabalhar em ambientes inteligentes
\begin_inset CommandInset citation
LatexCommand cite
key "Bandyopadhyay2011"

\end_inset

.
 Ambientes inteligentes referem-se a um mundo físico que é ricamente e invisivel
mente entrelaçada com sensores, atuadores, monitores e elementos computacionais,
 encaixado perfeitamente nos objetos do cotidiano de nossas vidas, e conectado
 através de uma rede contínua.
 A consciência do contexto inclui duas funcionalidades:
\end_layout

\begin_layout Itemize
A 
\emph on
detecção de contexto
\emph default
, que consiste em recolher os dados dos recursos, e selecionar a informação
 que pode ter um impacto sobre o cálculo.
 
\end_layout

\begin_layout Itemize

\emph on
Processamento de contexto
\emph default
, para usar as informações coletadas para realizar uma tarefa ou tomar uma
 decisão.
\end_layout

\begin_layout Subsubsection
Abstração da Aplicação
\end_layout

\begin_layout Standard
Este componente fornece uma interface de alto nível para aplicações e os
 utilizadores finais, para interação com os dispositivos.
 Por exemplo, esta interface pode ser uma interface REST ou pode ser implementad
a com alguma linguagem baseado na consulta.
\end_layout

\begin_layout Subsection
Padronização
\begin_inset CommandInset label
LatexCommand label
name "sub:MiddlewarePadronizacao"

\end_inset


\end_layout

\begin_layout Standard
Um único padrão para um middleware genérico de IoT, provavelmente não vai
 existir, devido ao grande número e diferentes tipos de aplicações e domínios
 envolvidos.
 No entanto, existem consideráveis esforços para proporcionar um solução
 de middleware padronizado, específico para um determinado domínio.
 Por exemplo, a visão proposta em 
\begin_inset CommandInset citation
LatexCommand cite
key "Katasonov2008"

\end_inset

 direciona-se no sentido de um middleware padronizado para o domínio de
 aplicações de web semântica, enquanto que a solução fornecida em 
\begin_inset CommandInset citation
LatexCommand cite
key "hauswirth2006middleware"

\end_inset

, tem como proposta oferecer uma abstração para uma plataforma única para
 ambientes de redes de sensores.
 Para ambientes inteligentes com uma infraestrutura fixa, como escritórios
 inteligentes, a solução fornecida em 
\begin_inset CommandInset citation
LatexCommand cite
key "roalter2010middleware"

\end_inset

 pode perfeitamente se adequar às exigências requeridas para o middleware
 neste contexto.
 Assim, é previsível que as plataformas de middleware para IoT terão mais
 do que um padrão para permitir aplicações em diferentes domínios.
 
\end_layout

\begin_layout Standard
O conjunto de padrões estabelecidos para o desenvolvimento de plataformas
 de middleware que venham atender os requisitos de todos os domínios de
 aplicações, podem formar uma plataforma de normalização para pesquisas
 e para indústria.
 Isto irá permitir a seleção do padrão desejado que se encaixa em uma determinad
a aplicação, dentro de um domínio específico.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Outra seção falando da Arquiteturas de Refência (Antes desta):
\end_layout

\begin_layout Plain Layout
2.1.1.
 IoT-A Architecture Reference Model (Master Thesis - Study)
\end_layout

\begin_layout Plain Layout
2.1.2.
 SENSEI Real World Internet Architecture (Master Thesis - Study)
\end_layout

\begin_layout Plain Layout
3.3.2.
 A arquitetura de referência do IoT-A (Plataformas para a Internet das Coisas.pdf
)
\end_layout

\begin_layout Plain Layout
3.3.3.
 WSO2 (Plataformas para a Internet das Coisas.pdf)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Considerações Finais 
\end_layout

\begin_layout Standard
Este capítulo apresentou um resumo dos conceitos, que fundamentam o desenvolvime
nto de middleware e firmware, bem como os protocolos envolvidos na construção
 de projetos de IoT.
 
\end_layout

\end_body
\end_document
